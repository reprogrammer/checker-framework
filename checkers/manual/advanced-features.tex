\htmlhr
\chapter{Advanced type system features\label{advanced-type-system-features}}

This chapter describes features that are automatically supported by every
checker written with the Checker Framework.
You may wish to skim or skip this chapter on first reading.  After you have
used a checker for a little while and want to be able to express more
sophisticated and useful types, or to understand more about how the Checker
Framework works, you can return to it.


\section{Array types\label{array-types}}

\section{Invariant array types\label{invariant-arrays}}

Java's type system is unsound with respect to arrays.  That is, the Java
type-checker approves code that is unsafe and will cause a run-time crash.
Technically, the problem is that Java has ``covariant array types'', such
as treating \<String[]> as a subtype of \<Object[]>.  Consider the
following example:

\begin{Verbatim}
  String[] strings = new String[] {"hello"};
  Object[] objects = strings;
  objects[0] = new Object();
  String myString = strs[0];
\end{Verbatim}

\noindent
The above code puts an \<Object> in the array \<strings> and thence in
\<myString>, even though \<myString = new Object()> should be, and is,
rejected by the Java type system.  Java prevents corruption of the JVM by
doing a costly run-time check at every array assignment; nonetheless, it is
undesirable to learn about a type error only via a run-time crash rather
than at compile time.

The Checker Framework is stricter than Java, in the sense that it treats
arrays invariantly rather than covariantly.  This means that a type system
built upon the Checker Framework is sound:  you get a compile-time
guarantee without the need for any run-time checks.  But it also means that
the Checker Framework rejects code that is similar to what Java unsoundly
accepts.  (The guarantee and the compile-time checks are about your
extended type system.  The Checker Framework does not reject the example
code above, in the absence of any type annotations.)


\section{Context-sensitive type inference for array constructors\label{array-context-sensitive}}

When you write an expression, the Checker Framework gives it the most
precise possible type, depending on the particular expression or value.
For example, when using the Regex Checker (\chapterpageref{regex-checker}),
the string \<"hello"> is given type \<@Regex String> because it is a legal
regular expression (whether it is meant to be used as one or not) and the
string \<"(foo"> is given the type \<@Unqualified String> because it is not
a legal regular expression.

Array constructors work differently.  When you create an array with the
array constructor syntax, such as the right-hand side of this assignmant:

\begin{Verbatim}
String[] myStrings = {"hello"};
\end{Verbatim}

\noindent
then the expression does not get the most precise possible type, because
doing so could cause inconvenience.  Rather, its type is determined by the
context in which it is used:  the left-hand side if it is in an assignment,
the declared formal parameter type if it is in a method call, etc.

In particular, if the expression \verb|{"hello"}| were given the type
\<@Regex String[]>, then the assignment would be illegal!  But the Checker
Framework gives the type \<String[]> based on the assignment context, so the code
type-checks.

If you prefer a specific type for a constructed array, you can indicate
that either in the context (change the declaration of \<myStrings>) or in a
\<new> construct (change the expression to \<new @Regex String[] >\verb|{"hello"}|).


\section{The effective qualifier on a type (defaults and inference)\label{effective-qualifier}}

A checker sometimes treats a type as having a slightly different qualifier
than what is written on the type --- especially if the programmer wrote no
qualifier at all.
Most readers can skip this section on first reading, because you will
probably find the system simply ``does what you mean'', without forcing
you to write too many qualifiers in your program.
In particular, qualifiers in method bodies are extremely rare.

Most of this section is applicable only to source code that is being
checked by a checker.
% TODO:  For defaulting rules when the compiler reads a
% \<.class> file, see Section~\ref{defaults-classfile}.

  The following steps determine the effective
qualifier on a type --- the qualifier that the checkers treat as being present.

\begin{enumerate}
\item
  The type system adds implicit qualifiers.  Implicit qualifiers can be
  built into a type system (Section~\ref{writing-type-introduction}), in
  which case the type system's documentation should explain all of the type
  system's implicit qualifiers.  Or, a programmer may introduce an implicit
  annotation on each use of class $C$ by writing a qualifier on the
  declaration of class $C$.

\begin{itemize}
\item
  Example 1 (built-in):  In the Nullness type system,
  \<enum> values are never null, nor is a method receiver.
\item
  Example 2 (built-in):  In the Interning type system, string literals
  and \<enum> values are always interned.
\end{itemize}

\item
  If a type qualifier is present in the source code, that qualifier is used.

  If the type has an implicit qualifier, then it is an error to write an
  explicit qualifier that is equal to (redundant with) or a supertype of
  (weaker than) the implicit qualifier.  A programmer may strengthen
  (write a subtype of) an implicit qualifier, however.

\item
  If there is no implicit or explicit qualifier on a type, then a default
  qualifier may be applied; see Section~\ref{defaults}.

%BEGIN LATEX
  % This looks bad in HTML.
  \smallskip
%END LATEX

  At this point (after step 3), every type has a qualifier.

\item
  The type system may refine a qualified type on a local variable --- that
  is, treat it as a subtype of how it was declared or defaulted.  This
  refinement is always sound and has the effect of eliminating false
  positive error messages.  See Section~\ref{type-refinement}.

  % Type
  % qualifier refinement is implemented by the \refclass{flow}{Flow} class.

\end{enumerate}



\subsection{Default qualifier for unannotated types\label{defaults}}

A type system designer, or an end-user programmer, can cause unannotated
references to be treated as if they had a default annotation.

There are several defaulting mechanisms, for convenience and flexibility.
When determining the default qualifier for a use of a type, the following
rules are used in order, until one applies.
\begin{itemize}
\item
  Use the innermost user-written \code{@DefaultQualifier}, as explained in
  this section.
\item
  Use the default specified by the type system designer
  (Section~\ref{typesystem-defaults}).
\item
  Use \code{@\refclass{quals}{Unqualified}}, which the framework
  inserts to avoid ambiguity and simplify the programming interface for
  type system designers.  Users do not have to worry about this detail,
  but type system implementers can rely on the fact that some
  qualifier is present.
\end{itemize}

% (Implementation detail:  setting defaults is implemented by the
% \refclass{util}{QualifierDefaults} class.)


The end-user programmer specifies a default qualifier by writing the \code{@\refclass{quals}{DefaultQualifier}}
annotation on a package, class, method, or variable declaration.  The
argument to \<@\refclass{quals}{DefaultQualifier}> is the \code{String}
name of an annotation.  It may be a short name like \code{"NonNull"}, if an
appropriate import statement exists.  Otherwise, it should be
fully-qualified, like \code{"checkers.nullness.quals.NonNull"}.
The optional second argument indicates where the default
applies.  If the second argument is omitted, the specified annotation is
the default in all locations.  See the Javadoc of \refclass{quals}{DefaultQualifier} for details.

For example, using the Nullness type system (Chapter~\ref{nullness-checker}):

\begin{Verbatim}
import checkers.quals.*;        // for DefaultQualifier[s]
import checkers.nullness.quals.NonNull;

@DefaultQualifier(NonNull.class)
class MyClass {

  public boolean compile(File myFile) { // myFile has type "@NonNull File"
    if (!myFile.exists())          // no warning: myFile is non-null
      return false;
    @Nullable File srcPath = ...;  // must annotate to specify "@Nullable File"
    ...
    if (srcPath.exists())          // warning: srcPath might be null
      ...
  }

  @DefaultQualifier(Mutable.class)
  public boolean isJavaFile(File myfile) {  // myFile has type "@Mutable File"
    ...
  }
}
\end{Verbatim}

If you wish to write multiple
\<@\refclass{quals}{DefaultQualifier}> annotations at a single location,
use
\<@\refclass{quals}{DefaultQualifiers}> instead.  For example:

\begin{Verbatim}
@DefaultQualifiers({
  @DefaultQualifier(NonNull.class),
  @DefaultQualifier(Mutable.class)
})
\end{Verbatim}


If \code{@DefaultQualifier}[\code{s}] is placed on a package (via the
\<package-info.java> file), then it applies to the given package \emph{and}
all subpackages.
% This is slightly at odds with Java's treatment of packages of different
% names as essentially unrelated, but is more intuitive and useful.

Recall that an annotation on a class definition indicates an implicit
qualifier (Section~\ref{effective-qualifier}) that can only be
strengthened, not weakened.  This can lead to unexpected results if
the default qualifier applies to a class definition.  Thus, you may want to
put explicit qualifiers on class declarations (which prevents the default
from taking effect), or exclude class declarations from defaulting.


%% Don't even bother to bring this up; it will just sow confusion without
%% being helpful.
% For some type systems, a user may not specify a default qualifier, or doing
% so prevents giving any other qualifier to any reference.  This is a
% consequence of the design of the type system; see
% Section~\ref{bottom-and-top-qualifier}.


When a programmer omits an \<extends> clause at a declaration of a type
parameter, the default still applies to the implicit upper bound.  For
example, consider these two declarations:

\begin{Verbatim}
  class C<T> { ... }
  class C<T extends Object> { ... }  // identical to previous line
\end{Verbatim}

\noindent
The two declarations are treated identically by Java, and the default
qualifier applies to the \<Object> upper bound whether it is implicit or
explicit.  (The @NonNull default annotation applies only to the upper bound
in the \<extends> clause, not to the lower bound in the inexpressible
implicit \<super void> clause.)


\subsection{Automatic type refinement (flow-sensitive type qualifier inference)\label{type-refinement}}

In order to reduce your burden of annotating types in your program, the
checkers soundly treat certain variables and expressions as having a
subtype of their declared or defaulted (Section~\ref{defaults})
type.  This functionality
never introduces unsoundness nor causes an error to be missed.

By default, all checkers, including new checkers that you write, can take
advantage of this functionality.  Most of the time, users don't have to
think about, and may not even notice, this feature of the framework.  The
checkers simply do the right thing even when a programmer omits an
annotation on a local variable, or when a programmer writes an
unnecessarily general type in a declaration.

The functionality has a variety of names:  automatic type refinement,
flow-sensitive type qualifier inference, local type inference, and
sometimes just ``flow''.

If you are curious or want more details about this feature, then read on.

As an example, the Nullness checker (Chapter~\ref{nullness-checker}) can automatically
determine that certain variables are non-null, even if they were explicitly
or by default annotated as nullable.
The checker treats a variable or expression as \code{@\refclass{nullness/quals}{NonNull}}
\begin{itemize}
\item
starting at the time that it is either
assigned a non-null value or checked against null (e.g., via an assertion,
\code{if} statement, or being dereferenced)
\item
until it might be re-assigned (e.g.,
via an assignment that might affect this variable, or via a method call
that might affect this variable).
\end{itemize}

As with explicit annotations, the implicitly non-null types permit
dereferences and assignments to non-null types, without
compiler warnings.

Consider this code, along with comments indicating whether the
Nullness checker (Chapter~\ref{nullness-checker}) issues a warning.  Note that the same expression may yield a
warning or not depending on its context.

\begin{Verbatim}
  // Requires an argument of type @NonNull String
  void parse(@NonNull String toParse) { ... }

  // Argument does NOT have a @NonNull type
  void lex(@Nullable String toLex) {
    parse(toLex);        // warning:  toLex might be null
    if (toLex != null) {
      parse(toLex);      // no warning:  toLex is known to be non-null
    }
    parse(toLex);        // warning:  toLex might be null
    toLex = new String(...);
    parse(toLex);        // no warning:  toLex is known to be non-null
  }
\end{Verbatim}

If you find examples where you think a value should be inferred to have
(or not have) a
given annotation, but the checker does not do so, please submit a bug
report (see Section~\ref{reporting-bugs}) that includes a small piece of
Java code that reproduces the problem.

% Flow-sensitive non-null inference has been implemented for the following
% varieties of expressions:
%
% \begin{itemize}
% \item null checks in if/else statements
% \item null checks in assert statements
% \item null checks that result in a return or thrown exception, or call System.exit
% \item assignments from new class/array expressions
% \end{itemize}
%
% \emph{Note:} The items in the above list exclude complex null checks, i.e., not
% of the form \code{x != null}. Support for these types of checks will be available in a
% future release.


The inference indicates when a variable can be treated as having a subtype
of its declared type --- for instance, when an otherwise nullable type can be
treated as a \code{@\refclass{nullness/quals}{NonNull}} one.  The inference never treats a variable as
a supertype of its declared type (e.g., an expression of \code{@\refclass{nullness/quals}{NonNull}}
type is never inferred to be treated as possibly-null).

% TODO:  Is NonNull inferred for any parameters or fields, or just for locals?

Type inference is never performed for method parameters of non-private
methods, nor for non-private fields.  
More generally, the inferred information is never written to the
\code{.class} file as user-written annotations are.
If the checker did inference in externally-visible locations and wrote it
to the \<.class> file, then the resulting \<.class> file would be different
depending on whether an annotation processor had been run or not.  It is a
design goal that the same annotations appear in the \<.class> file
regardless of whether the class is compiled with or without the checker,
and this requires that any public signature be fully annotated by the user
rather than inferred.


\subsection{Fields and flow sensitivity analysis}

Flow sensitivity analysis infers the type of fields in some restricted cases:

\begin{itemize}

\item
A final initialized field:
Type inference is performed for final fields that are initialized to a
compile-time constant at the declaration site; so the type of \code{protocol}
is \code{@NonNull String} in the following declaration:

\begin{Verbatim}
    public final String protocol = "https";
\end{Verbatim}

Please note that such inferred type may leak to the public interface of the
class.  To override such behavior, you can explicitly insert the desired
annotation, e.g.,

\begin{Verbatim}
    public final @Nullable String protocol = "https";
\end{Verbatim}

\item
Within method bodies:
Type inference is performed for fields in the context of method bodies,
like local variables, but method invocations invalidate any inferred
information.  Consider the following example, where \code{updatedAt} is a nullable
field:

\begin{Verbatim}
class DBObject {
  @Nullable Date updatedAt;

  void persistData() {
    ... // write to disk or other non-volatile memory
    updatedAt = null;
  }

  void update() {
    if (updatedAt == null)
        updatedAt = new Date();
    // updatedAt is nonnull
    log("Updating object at " + updatedAt.getTime());

    persistData();
    // updatedAt is nullable again
    log.debug("Saved object updated at " + updatedAt.getTime()); // invalid!
  }
}
\end{Verbatim}

Here the call to \code{persistData()} invalidates the inferred non-null type
of \code{updatedAt}.

When methods do not modify any object state or have any identity side-effects
(e.g., \code{log()} method here), you can annotate these methods as
\code{Pure}.  When a method is annotated as \code{Pure}, the flow analyzer
carries the inferred types across the method invocation boundary.

\end{itemize}


\subsection{Inherited defaults\label{inherited-defaults}}

In certain situations, it would be convenient for an annotation on a
superclass member to be automatically inherited by subclasses that override
it.  This feature would reduce both annotation effort and program
comprehensibility.  In general, a program is read more often than it is
edited/annotated, so the Checker Framework does not currently support this
feature.  Here are more detailed justifications:

\begin{itemize}

\item
  Currently, a user can determine the annotation on a parameter or return
  value by looking at a single file.  If annotations could be inherited
  from supertypes, then a user would have to examine all supertypes to
  understand the meaning of an unannotated type in a given file.

\item
  Different annotations might be inherited from a supertype and an
  interface, or from two interfaces.  Presumably, the subtype's annotations
  would be stronger than either (the greatest lower bound in the type
  system), or an error would be thrown if no such annotations existed.

\end{itemize}

If these issues can be resolved, then the feature may be added in the
future.  Or, it may be added optionally, and each type-checker
implementation can enable it if desired.


\iffalse TODO
\subsection{Default qualifiers for \<.class> files\label{defaults-classfile}}

The defaulting rules presented so far apply to source code that is read by
the compiler.  When the compiler reads a \<.class> file, different
defaulting rules apply.

If the checker was run during the compiler execution that created the
\<.class> file (and the qualifier hierarchy has both a top and a bottom
qualifier, see Section~\ref{top-qualifier}), then there is no need for
defaults:  the \<.class> file has an explicit qualifier at each type use.
Furthermore, unless warnings were suppressed, those qualifiers are
guaranteed to be correct.
When you are performing pluggable type-checking,
it is best to ensure that the compiler only reads such \<.class> files.

If the checker was not run during the compiler execution that created the
\<.class> file, then the \<.class> file contains only the type qualifiers
that the programmer wrote explicitly.  Furthermore, there is no guarantee
that these qualifiers are correct, since they have not been checked.
In this case, the checker must decide what qualifier to use for the
locations where the programmer did not write an annotation:
\begin{itemize}
\item
  For method parameters, use the bottom qualifier (see
  Section~\ref{bottom-qualifier}).
\item
  For method return values, use the top qualifier (see 
  Section~\ref{top-qualifier}).
\item
  For fields, use the bottom qualifier when writing to the field and the
  top qualifier when reading from the field.
%% TODO: should give rules for other locations, such as type parameters
%% (which should behave like fields), bounds, etc.
\end{itemize}

These \<.class> file defaulting rules are very strict.  If your code uses a
library that was not created when running the checker, then your uses of
that library probably will not type check.  This is intentional --- it is
better than the type checker silently permitting such uses.
To eliminate the errors, you should either re-compile the library while
running the checker to create new \<.class> and/or \<.jar> files, or you
should suppress the warnings (see Section~\ref{suppressing-warnings}).

TODO
\fi


% If you add a Javadoc link to this location, also add the qualifier to the
% list below.
\section{Writing Java expressions as annotation arguments\label{java-expressions-as-arguments}}

Sometimes, it is necessary to write a Java expression as the argument to an
annotation.  As of this writing, the annotations that take a Java
expression as an argument are:

\begin{itemize}
\item \code{@\refclass{nullness/quals}{KeyFor}}
\item \code{@\refclass{nullness/quals}{RequiresNonNull}}
\item \code{@\refclass{nullness/quals}{EnsuresNonNull}}
\item \code{@\refclass{nullness/quals}{EnsuresNonNullIf}}
\end{itemize}

The expression is a subset of legal Java expressions:

\begin{itemize}
\item
  the receiver object, \<this>.
\item
  a formal parameter.  Write \<\#> followed by the one-based parameter
  index.  For example: \<\#1>, \<\#3>.  It is not permitted to write \<\#0>;
  use \<this> instead.
\item
  a local variable.  This is not applicable for method annotations, but is
  applicable to type annotations such as
  \code{@\refclass{nullness/quals}{KeyFor}}.  Write the variable name.  For
  example: \<myLocalVar>.
\item
  a static variable.  Write the class name and the variable, as in
  \<System.out>.
  % It may also work to use an instance variable and the static variable
  % name, but I'm not sure about that.

  % True as of 7/6/2011.  This limitation should be fixed.
  Within the class itself, just write the field name --- do not write the
  class name.
\item
  a field of any expression.  For example:  \<next>,
  \<this.next>, \<\#1.next>, \<myLocalVar.next>.
\item a method invocation on any expression.
  The method must be pure and have no formal parameters.  For example:
  \<myClass.getPackage()>, \<myClass.getSuperclass()>,
  \<myClass.getComponentType()>.

  \textbf{Warning:}  currently, annotations that use method calls are
  \emph{not} checked.  The annotation is trusted, and other code will rely
  on it, but it is not verified that other code establishes or maintains
  the validity of the annotation.  Such expressions are still useful if a
  human verifies their correctness.  They are used in the JDK annotations,
  for example.
\end{itemize}

You may optionally omit a leading ``\<this.>'', just as in Java.  Thus, 
\<this.next> and \<next> are equivalent, assuming that there is no
shadowing definition of \<next>.

\textbf{Limitation:}  Currently, only one level of field access can be
checked; the checker cannot handle, for example, \code{"this.field1.field2"}.

(A side note:  The formal parameter syntax \<\#1> may seem less convenient
than writing the formal parameter name.  This syntax is necessary because
in the \<.class> file, no parameter name information is available.  Running
the compiler without a checker should create legal annotations in the
\<.class> file, so we cannot rely on the checker to translate names to
indices.)


%% Remove this section, since its example is now expressible.
%% TODO: Find another example, and reinstate this section.
% \section{Inexpressible types\label{inexpressible-types}}
% 
% The Type Annotations syntax~\cite{JSR308-2008-09-12} is designed to be easy to read.  As a result,
% there are types that it cannot express.  An example is the type of
% \<Collection.toArray()>, which returns an array of objects, where the
% objects have the same annotation as the elements of the receiver.
% 
% This can be written as
% 
% \begin{Verbatim}
% public @PolyNull Object [] toArray(Collection<@PolyNull E> this) { ... }
% \end{Verbatim}
% 
% \noindent
% except that this is illegal syntax:  ``\code{ArrayList<@PolyNull E>}'' is
% not legal in the receiver position.  (This is a motivation for
% \ahref{http://types.cs.washington.edu/jsr308/specification/java-annotation-design.html#receiver-type-parameter-annotations}{extending}
% the Type Annotations syntax.)
% 
% The annotated libraries (Section~\ref{annotating-libraries}) contain a less-precise annotation for
% \code{toArray}.  The Nullness Checker special-cases \code{toArray} to
% act as if it had the above annotation.  The cases that
% are currently being handled are described in
% \refclass{nullness}{CollectionToArrayHeuristics}.
% This approach would be possible for other checkers and other methods as the
% need arises.


\section{Unused fields and dependent types\label{unused-fields-and-dependent-types}}

In an inheritance hierarchy, subclasses often introduce new methods and
fields.  For example, a \<Marsupial> (and its subclasses such as
\<Kangaroo>) might have a variable indicating the size of the animal's
pouch.  Because such variables would not exist in superclasses such as
\<Mammal> and \<Animal>, any attempt to use them would be a compile-time
error.

If you cannot use subtypes but wish to enforce similar requirements using
type qualifiers, you can do so.  To restrict which methods may be invoked,
you can write an annotation on a method receiver; then the method may only
be invoked on an expression whose type has the given annotation (or one of
its subtypes).  Section~\ref{unused-fields} describes how to restrict which
fields may be accessed:  in other words, a given field may only be accessed
from an expression whose type has a given qualifier.  Then,
Section~\ref{dependent-types} describes an even more powerful mechanism, by
which the qualifier of a field depends on the qualifier of the expression
from which the field was accessed.
(Also see the discussion of typestate checkers, in
Chapter~\ref{typestate-checker}.)


\subsection{Unused fields\label{unused-fields}}

A Java subtype can have more fields than its supertype.  For example:

\begin{Verbatim}
class Mammal extends Animal { ... }
class Marsupial extends Mammal {
  ...
  int pouchSize;  // pouch capacity, in cubic centimeters
  ...
}
\end{Verbatim}

You can simulate
the same effect for type qualifiers:  a given field may not be accessed via
a reference with a supertype qualifier, but can be accessed via a reference
with a subtype qualifier.
For example:

\begin{Verbatim}
@interface Mammal { }
@interface Marsupial { }
class Animal {
  @Unused(when=Mammal.class)
  int pouchSize;  // pouch capacity, in cubic centimeters
  ...
}

@Marsupial Animal joey = ...;
... joey.pouchSize ...    // OK
@Mammal Animal mae = ...;
... mae.pouchSize ...    // compile-time error
\end{Verbatim}

The \code{@\refclass{quals}{Unused}} annotation
on a field declares that the field may \emph{not} be accessed via a receiver of
the given qualified type (or any \emph{super}type).

(It would probably be clearer to replace \<@Unused> by an annotation that
indicates when the field \emph{may} be used.)


\subsection{Dependent types\label{dependent-types}}

A variable has a \emph{dependent type} if its type depends on some other
value or type.
%  --- the type is dynamically, not statically, determined.
% (Type-safety can still be statically determined, though.)

The Checker Framework supports a form of dependent types, via the
\code{@\refclass{quals}{Dependent}} annotation.
This annotation changes the type of a field or variable, based on the
qualified type of the receiver (\code{this}).  This can be viewed as a more
expressive form of polymorphism (see Section~\ref{polymorphism}).  It can
also be seen as a way of linking the meanings of two type qualifier
hierarchies.

Here is a restatement of the example of Section~\ref{unused-fields}, using
\code{@\refclass{quals}{Dependent}}:

\begin{Verbatim}
@interface Mammal { }
@interface Marsupial { }
class Animal { ...
  // pouch capacity, in cubic centimeters
  // (non-null if this animal is a marsupial)
  @Nullable @Dependent(result=NonNull.class, when=Marsupial.class) Integer pouchSize;
  ...
}

@Marsupial Animal joey = ...;
... joey.pouchSize.intValue() ...    // OK
@Mammal Animal mae = ...;
... mae.pouchSize.intValue() ...    // compile-time error:
                                    //   dereference of possibly-null mae.pouchSize
\end{Verbatim}

However, when the \code{@\refclass{quals}{Unused}} annotation is sufficient, you
should use it instead of \code{@Dependent}.

% TO DO:  give an example where @Dependent is actually needed


% LocalWords:  MyClass quals PolymorphicQualifier DefaultQualifier subpackages
% LocalWords:  DefaultQualifiers actuals toArray CollectionToArrayHeuristics nn
% LocalWords:  MyList Nullness DefaultLocation nullness PolyNull util java TODO
% LocalWords:  QualifierDefaults nullable lub persistData updatedAt nble KeyFor
% LocalWords:  subtype's RequiresNonNull EnsuresNonNull EnsuresNonNullIf
% LocalWords:  myLocalVar myClass getPackage getSuperclass
% LocalWords:  getComponentType enum implementers dereferenced superclasses
