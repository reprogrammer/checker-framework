\htmlhr
\chapter{Annotating libraries\label{annotating-libraries}}

When annotated code uses an unannotated library, a checker may issue warnings.
As described in Section~\ref{unannotated-code}, the best way to correct
this problem is to add annotations to the library.  (Alternately, you can instead
suppress all warnings related to an unannotated library by use of the
\code{-AskipUses} command-line option; see
Section~\ref{suppressing-warnings}.)  If you have source code for the
library, you can easily add the annotations.
This chapter tells you
how to add annotations to a library for which you have no source code,
because the library is distributed only in binary form
(as \code{.class} files, possibly packaged in a \code{.jar} file).
This chapter is also useful if you do not wish to edit the
library's source code.

You can make the annotations known to the checkers in two ways.

\begin{itemize}

\item
  You can write annotations in a ``stub
  file'' containing classes with no method bodies.
  Section~\ref{stub} describes how to create and use stub files.

\item
  You can insert annotations in the compiled
  \code{.class} files of the library.
  You would express the annotations textually, typically as an annotation index file, and
  then insert them in the library by using the Annotation File Utilities
  (\myurl{http://types.cs.washington.edu/annotation-file-utilities/}).
  See the Annotation File Utilities documentation for full details.

\end{itemize}

The Checker Framework distribution contains annotations for popular
libraries, such as the JDK\@.  It uses both of the above mechanisms.  The
Nullness, Javari, IGJ, and Interning Checkers use an annotated JDK
(Section~\ref{skeleton}), and all other checkers use stub files
(Section~\ref{stub}).

If you annotate additional libraries, please share them with us so that we
can distribute the annotations with the Checker Framework; see
Section~\ref{reporting-bugs}.
You can determine the correct annotations for a library either
automatically by running an inference tool, or manually by reading the
documentation.  Presently, type inference tools are available for the
Nullness (Section~\ref{nullness-inference}) and Javari
(Section~\ref{javari-inference}) type systems.


\section{Choosing between stub files and annotated \<.class> files\label{stub-vs-class-files}}

A checker can read annotations either from a stub file or from a library's
\<.class> files.  This section helps you choose between the two alternatives.

Once created, a stub file can be used directly; this makes it an easy way
to get started with library annotations.
When provided by the author of the checker, a stub file is used
automatically, with no need for the user to supply a command-line option.

Inserting annotations in a library's \<.class> files takes an extra step
using an external tool, the Annotation File Utilities
(\myurl{http://types.cs.washington.edu/annotation-file-utilities/}).
However, this process does not suffer the limitations of stub files, such
as its inability to handle declaration annotations
(Section~\ref{stub-limitations}).


\section{Using stub classes\label{stub}\label{stub-creating-and-using}}

A stub file contains ``stub classes'' that contain annotated signatures,
but no method bodies.  A
checker uses the annotated signatures at compile time, instead of or in
addition to annotations that appear in the library.

Section~\ref{stub-creating} describes how to create stub classes.
Section~\ref{stub-using} describes how to use stub classes.
These sections illustrate stub classes via the example of creating a \code{@\refclass{interning/quals}{Interned}}-annotated
version of \code{java.lang.String}.  You don't need to repeat these steps
to handle \code{java.lang.String} for the Interning Checker,
but you might do something similar for a different class and/or checker.

% First, you must install the skeleton class generator
% (Section~\ref{skeleton-installing}).

\subsection{Creating a stub file\label{stub-creating}}

Every Java file is a stub file.  If you have access to the Java file, then
it is usually best to use the Java file as the stub file, without removing
any of the parts that the stub file format permits you to.  Just add
annotations to the signatures, leaving the method bodies unchanged.
This approach retains the original
documentation and source code, making it easier for a programmer to
double-check the annotations.  It also enables creation of diffs, easing
the process of upgrading when a library adds new methods.  And, the
annotations are in a format that the library maintainers can even
incorporate.

The downside of this approach is that the stub files are larger.  This can
slow down parsing.  Furthermore, a programmer must search the stub file
for a given method rather than just skimming one or two pages of signatures.

If you do not have access to the library source code, then you can create a
stub file from the class file (Section~\ref{stub-creating}),
and then annotate it.  The rest of this section describes this approach.


\begin{enumerate}

\item
  Create a stub file by running the stub class generator.  (\<checkers.jar>
  must be on your classpath.)

\begin{Verbatim}
  cd nullness-stub
  java checkers.util.stub.StubGenerator java.lang.String > String.astub
\end{Verbatim}

  Supply it with the fully-qualified name of the class for which you wish to
  generate a stub class.  The stub class generator prints the
  stub class to standard out, so you may wish to redirect its output to a
  file.

\item
  Add import statements for the annotations.  So you would need to
add the following import statement at the beginning of the file:

\begin{Verbatim}
  import checkers.interning.quals.Interned;
\end{Verbatim}

\item
  Add annotations to the stub class.  For example, you might annotate
  the \sunjavadoc{java/lang/String.html#intern()}{String.intern()} method as follows:

\begin{Verbatim}
  @Interned String intern();
\end{Verbatim}

  You may also remove irrelevant parts of the stub file; see
  Section~\ref{stub-format}.

\end{enumerate}

\subsection{Using a stub file\label{stub-using}}

The \code{-Astubs} argument causes the Checker Framework to read
annotations from annotated stub classes in preference to the unannotated
original library classes.  For example:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  javac -processor checkers.interning.InterningChecker -Astubs=String.astub:stubs MyFile.java MyOtherFile.java ...
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

Each stub path entry is a file or a directory; specifying a directory is
equivalent to specifying every file in it whose name ends with
\code{.astub}.  The stub path entries are delimited by
\<File.pathSeparator> (`\<:>' for Linux and Mac, `\<;>' for Windows).

A checker automatically reads the stub file \code{jdk.astub}.  (The checker
author should place it in the same directory as the Checker class, i.e.,
the subclass of \code{BaseTypeVisitor}.)  Programmers should only use the
\<-Astubs> argument for additional stub files they create themselves.

% \textbf{The following is not implemented yet}
% A library writers should create a file \code{library.astub} on the
% classpath (in the resources directory or the binary jars).
% The Checker Framework automatically imports all the stub files named
% \code{library.astub} found in the classpath.  





\subsection{Stub file format\label{stub-format}}

Every Java file is a valid stub file.  However, you can omit information
that is not relevant to pluggable type-checking; this makes the stub file
smaller and easier for people to read and write.

As an illustration, a stub file for the Interning type system
(Chapter~\ref{interning-checker}) could be:

\begin{Verbatim}
  import checkers.interning.quals.Interned;
  package java.lang;
  @Interned class Class<T> { }
  class String {
    @Interned String intern();
  }
\end{Verbatim}





The stub file format is allowed to differ from Java source code in the
following ways:
\begin{description}

\item{\textbf{Method bodies:}}
  The stub class does not require method bodies for classes; any method
  body may be replaced by a semicolon (\code{;}), as in an interface or
  abstract method declaration.

\item{\textbf{Method declarations:}}
  You only have to specify the methods that you need to annotate.
  Any method declaration may be omitted, in which case the checker reads
  its annotations from library's \<.class> files.  (If you are using a stub class, then
  typically the library is unannotated.)

\item{\textbf{Declaration specifiers:}}
  Declaration specifiers (e.g., \<public>, \<final>, \<volatile>)
  may be omitted.

\item{\textbf{Import statements:}}
  The only required import statements are the ones to import type
  annotations.  Such imports must be at the beginning of the
  file.  Other import statements are optional.

\item{\textbf{Multiple classes and packages:}}
  The stub file format permits having multiple classes and packages.
  The packages are separated by a package statement:
  \<package my.package;>.  Each package declaration may occur only once; in
  other words, all classes from a package must appear together.

\end{description}


\subsection{Limitations\label{stub-limitations}}

The stub file reader has several limitations:

\begin{itemize}
\item
  % Still a problem as of 9/2/2009.
  It does not handle \code{enum}s.
\item
  % Still a problem as of 9/2/2009.
  It only handles type annotations, not declaration annotations (e.g.,
  IGJ's \<@Assignable> or Interning's \<@UsesObjectEquals>).
\item
  It does not handle nested classes.  To work around this, it permits a
  top-level class to be written with a \<\$> in its name, and applies the
  annotations to the appropriate nested class.
\end{itemize}

If these limitations are a problem, then you should insert annotations
in the library's \<.class> files instead.


% Label "skeleton" is for old links from the Javarifier manual, to prevent
% them from being broken links.

\section{Using distributed annotated JDKs\label{skeleton-using}\label{skeleton}}

The Checker Framework distribution contains
annotated JDKs at the path \<checkers/jdk/jdk.jar>.
The \<javac> that is distributed with the Checker Framework uses the
annotated JDKs by default.

If you use a different \<javac>, then you must add a
\code{-Xbootclasspath/p:} argument, which causes the compiler to read
annotations from annotated JDK classes in preference to the unannotated
original library classes.  Supply \code{-Xbootclasspath/p:} in addition to
whatever other arguments you usually use, including \code{-classpath}.  For example:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  javac -processor checkers.nullness.NullnessChecker -Xbootclasspath/p:${CHECKERS}/jdk/jdk.jar my_source_files
\end{Verbatim}
% Unconfuse Emacs font lock mode: $
%BEGIN LATEX
\end{smaller}
%END LATEX

If you do not supply the \code{-Xbootclasspath/p:} option, the checker will
print a message warning you to do so.  In the unlikely event that you want
to suppress this warning, use \code{-Anocheckjdk}.


The annotated JDK should \emph{not} be in your classpath at run time, only
at compile time.

The supplied annotated JDK is a version of JDK 6.  If you wish to have an
annotated version of JDK 7, you will need to create it yourself.  Running
\<ant jdk.jar> from the \<checkers/> directory will perform this process.


% Skeleton classes are inferior to stub classes for two reasons.  First,
% skeleton files must be on the classpath during compilation but must
% \emph{not} be on the classpath during execution; this is inconvenient and
% error-prone.  Second, the skeleton files contain incorrect values for
% certain static final fields.  These incorrect values can lead to
% run-time problems unless the Java code is re-compiled without the skeleton
% classes after type-checking is complete.



% \section{Installing the skeleton class generator\label{skeleton-installing}}
%
% Source code for the skeleton class generator tool is included in the
% Checker Framework
% distribution, but because the tool has additional dependencies, the provided
% build script does not build the tool by default.
%
% Follow these steps to install the skeleton class generator:
%
% \begin{enumerate}
%
% \item
%   Install the annotation file utilities, using the instructions at
%   \myurl{http://types.cs.washington.edu/annotation-file-utilities/}.
%   Per those instructions, the \code{annotation-file-utilities.jar} file
%   should be on your classpath.
%
% % TODO This item should become optional; tell people to install the AFU in
% % the right place.
% \item
%   Update the \code{build.properties} file in the Checker Framework distribution so
%   that the \code{annotation-utils.lib} property specifies the location of
%   the \code{annotation-file-utilities.jar} library.
%
% \item
%   Build the skeleton class generator tool by running \code{ant
%     skeleton-util dist} in the \code{checkers} directory.  This updates the
%   \code{checkers.jar} file to contain the skeleton class generator.
%   \code{checkers.jar} should already be on your classpath (see
%   Section~\ref{installation}).
%
% \end{enumerate}


% LocalWords:  plugin utils util dist RuntimeException NonNull TODO AFU enum
% LocalWords:  sourcepath Nullness javac classpath src quals pathSeparator JDKs
% LocalWords:  IGJ's jdk Astubs skipUses astub AskipUses toArray IGJ
% LocalWords:  CollectionToArrayHeuristics BaseTypeVisitor Xbootclasspath
% LocalWords:  Interning's UsesObjectEquals Anocheckjdk
