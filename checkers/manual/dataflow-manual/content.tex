
\section{Introduction}

This document describes a \emph{dataflow analysis framework} for the Java Programming Language.
In particular, the framework is designed to be used in the Checker Framework, a framework
that adds pluggable types to the Java type system.

\begin{workinprogress}
    The dataflow framework is currently a work in progress. This document does not necessarily describe
    the latest state of the design and/or implementation.
    
    Paragraphs colored in gray with a gray bar on the left side (just like this one)
    contain questions, additional comments or indicate missing parts. Eventually, these
    paragraphs will be removed.
\end{workinprogress}





\section{The Control Flow Graph}
\label{sec:cfg}

%In this section, we describe the control flow graph (CFG), and the translation from the
%Java abstract syntax tree (AST) to the CFG.

The dataflow framework described here is designed to perform an intra-procedural analysis.
This analysis is modular and every method is considered in isolation. In this section
we describe the control flow graph (CFG), which is used to represent a single method, and the
translation from the abstract syntax tree (AST) to the CFG. We start with a simple
example, then give a more formal definition of the CFG and its properties and finally
describe the translation from the AST to the CFG.

As is standard, a control flow graph in our framework is a set of basic blocks
that are linked by control flow edges. Possibly less standard,
every basic block consists of a sequence
of so-called nodes, which correspond to a minimal Java operations or expression.


\flow{Simple}{A simple Java code snipped to introduce the CFG.}

Consider the method \code{test} of \autoref{lst:CFGSimple} whose control
flow graph is shown in \autoref{fig:CFGSimple}. The if conditional got translated to
a \emph{conditional basic block} with two successors. There are also two
special basic blocks to denote the entry and exit point of the method.


\subsection{Formal Definition of the Control Flow Graph}
\label{sec:cfg-formal}

\begin{definition}[Control Flow Graph]
    A \emph{control flow graph} consists of a set of \emph{basic blocks} and
    a set of directed edges between these basic blocks, some of which are labeled.
\end{definition}

\begin{definition}[Basic Block]
    A \emph{basic block} is a sequence of \emph{nodes}, where there is no
    control flow occurring between those nodes and nodes of other basic
    blocks, except between the last node of one block $b_1$ and the first node
    of another block $b_2$, if $b_2$ is a successor of $b_1$.
    Furthermore, the only control flow between the nodes inside
    the basic block is sequential.
    
    As is standard, the control flow graph models all paths that can possibly be taken by
    an execution of the method.
\end{definition}



\begin{definition}[Types of Basic Blocks]
    There are three \emph{types} of basic blocks in a control flow graph:
    \begin{enumerate}
        \item \textbf{Special basic blocks.} A \emph{special basic block} contains
        the empty sequence of nodes (i.e., is empty) and denotes either the
        entry or one of the exit blocks of a method. There are three types
        of special basic blocks:
        \begin{itemize}
            \item Entry block. This basic block is the (only) entry point of the
            method and thus the only basic block without predecessors.
            \item Exit block. This basic block denotes the (normal) exit of
            a method, and it does not have successors.
            \item Exceptional exit block, which indicates exceptional termination
            of the method. As the exit block, this block does not have successors.
        \end{itemize}
        Every method has exactly one entry, zero or one exit blocks and zero or one
        exceptional exit blocks. However, there is either an exit block or an exceptional
        exit block.
        \item \textbf{Regular basic block.} A \emph{regular basic block} contains
        any non-empty sequence of nodes, and has exactly one successor.
        None of the nodes in the block can throw an exception at runtime.
        \item \textbf{Exception basic block.} An \emph{exception basic block} contains exactly
        one node that \emph{might} throw an exception at runtime (e.g., a method call).
        There is zero or one non-exceptional successor, and one
        or more exceptional successors (see \autoref{def:edges}). But in all cases there
        is at least one successor (regular or exceptional), and only a basic block
        containing a \code{throw} statement does not have a non-exceptional successor.
        \item \textbf{Conditional basic block.} A \emph{conditional basic block}
        does not contain any nodes and is used as a \emph{split point} after the execution
        of a node of boolean type. It has exactly two successors (both non-exceptional); one
        if the previous node evaluates to true, and another
        if the node evaluates to false. Both successors are labeled accordingly.
        
        There is always exactly a single predecessor block for every conditional basic block, which
        is either a regular basic block or an exception basic block. In both cases, the last node
        in the predecessor (or the only one for an exceptional basic block) will be of boolean type.
    \end{enumerate}
\end{definition}

In the visualizations used in this document (e.g., in \autoref{fig:CFGSimple}), special basic blocks are
shown as ovals, conditional basic blocks are polygons with eight sides and any
other basic block appears as rectangle.

\begin{definition}[Control Flow Graph Edges]
\label{def:edges}
The basic blocks of a control flow graph are connected by directed \emph{edges}.
If $b_1$ and $b_2$ are connected by a directed edge $(b_1,b_2)$, we call
$b_1$ the predecessor of $b_2$, and $b_2$ the successor of $b_1$.
In a control flow graph, there are three types of edges:
\begin{enumerate}
    \item \textbf{Exceptional edges}. An \emph{exceptional edge} connects an exception basic block
    basic block with its exceptional successors, and it is labeled by the most
    general exception that might cause the execution to take this edge during runtime.
    Note that the outgoing exceptional edges of a basic block do not need to have mutual
    exclusive labels; the semantics is that the control flow follows the most specific
    edge. For instance, if one edge is labeled with type \code{A} and another is labeled
    with type \code{B} where \code{B} is a subtype of \code{A}, then the execution only takes
    the first edge if the exception is of a subtype of \code{A}, but not a subtype of \code{B}.
    
    There is at most one successor for every exception type.
    \item \textbf{Conditional edges}. A \emph{conditional edge} is a non-exceptional
    edge that connects a conditional
    basic block with one of its successors, and is labeled with either ``true'' or
    ``false''.
    \item \textbf{Regular, non-conditional edge.} Any other edge is a \emph{regular edge}, and does not carry
    a label. Only regular basic blocks, the entry basic block and exception basic blocks have outgoing
    regular edges.
\end{enumerate}
\end{definition}


\begin{workinprogress}
    The following definition of nodes is rather vague. Tips for improvements are welcome.
\end{workinprogress}
\begin{definition}[Nodes]
    \label{def:node}
    A \emph{node} is a minimal Java operation or expression.
    It is minimal in the sense that it cannot be decomposed further into subparts
    between which control flow occurs. Examples for such nodes include integer literals,
    an addition node (that performs the mathematical addition of two nodes) or a method call.
    The full list of nodes is given in \autoref{tab:nodes} and several of them
    are described in more detail in \autoref{sec:noteworthy-translations}.
    
    It is important to note that, even though nodes can contain references to other nodes,
    it is only that ``top-level'' node which is considered at that point in the basic
    block. In our example of the addition node, this means that only the addition operation
    is to be executed, and its operands would occur earlier in the control flow graph
    (as they are evaluated first, before performing the addition).
\end{definition}

In the visualization, a string representation of the node is used, followed by the name
of the node type in square brackets. Note that the string representation often also includes
more than just the ``top-level'' node. For instance, an addition node also displays its
left and right operator. This is done for clarity, so that it is easy to see what
expressions are summed up.

In \autoref{tab:nodes} we give a list of all node types in our framework. We use the
Java class name of the implementation, but leave out the suffix \code{Node}, which is present
for all types.

    \begin{longtable}{lp{0.6\linewidth}l}
        \textbf{Node type} & \textbf{Notes} & \textbf{Example} \\ \midrule \endhead
        \code{IntegerLiteral} & An integer constant. & \code{42}\\
        \code{FieldAccess} & Any access to a field, either implicit or explicit. & \code{f}, \code{obj.f}\\
        \code{ImplicitThis} & A node without corresponding AST element to indicate
        an implicit access on the self reference \code{this}. & - \\
        \code{Assignment} & An assignment. & \code{a = 1}\\
        \code{VariableDeclaration} & Declaration of a local variable. Does not include
        an initialization of the variable. If there was an initializer block in the
        AST, then this node is followed by an \code{AssignmentNode}. & \code{int a} \\
        \code{ConditionalOr} & The conditional disjunction node has a field \code{result}
        that can be \code{true}, \code{false} or \code{null}, depending on the knowledge of
        its evaluation result we have (cf.~\autoref{sec:cond-exp}). & \code{b || c} \\
        \midrule \multicolumn{3}{l}{\emph{Node types added on 2012-01-14:}} \\ \midrule
        \code{ByteLiteral} &  & \\
        \code{ShortLiteral} &  & \\
        \code{LongLiteral} &  & \\
        \code{FloatLiteral} &  & \\
        \code{DoubleLiteral} &  & \\
        \code{CharacterLiteral} &  & \\
        \code{BooleanLiteral} &  & \\
        
        \code{NullLiteral} & The \code{null} literal. & \\
        
        \code{ExplicitThis} & Explicit access of the self reference \code{this}. & \\
        \code{Super} & The \code{super} literal. & \\
        \midrule
        \code{ArrayAccess} &  & \\
        \midrule
        \code{NumericalAddition} & Addition of any numerical type (int, float, etc.). Integer, Float, etc.
        do not need to be handled, as there is an explicit \code{UnboxingNode} & \\
        \code{NumericalSubtraction} &  & \\
        \code{NumericalMultiplication} &  & \\
        \code{IntegerDivision} & Division for int, long, short, etc. Can throw exception. & \\
        \code{FloatDivision} & Division for float and double. Cannot throw exception. & \\
        \code{IntegerRemainder} & Remainder for int, long, short, etc. Can throw exception. & \\
        \code{FloatRemainder} & Remainder for float and double. Cannot throw exception. & \\
        \code{NumericalMinus} & Unary minus. & \\
        \code{NumericalPlus} & Unary plus. & \\
        \code{LeftShift} &  & \\
        \code{SignedRightShift} &  & \\
        \code{UnsignedRightShift} &  & \\
        \midrule
        \code{StringConcatenate} &  & \\
        \midrule
        \code{PrefixIncrement} &  & \\
        \code{PrefixDecrement} &  & \\
        \code{PostfixIncrement} &  & \\
        \code{PostfixDecrement} &  & \\
        \midrule
        \code{LessThanNode} &  & \\
        \code{LessOrEqualThanNode} &  & \\
        \code{GreaterThanNode} &  & \\
        \code{GreaterOrEqualThanNode} &  & \\
        \code{EqualToNode} &  & \\
        \code{NotEqualNode} &  & \\
        \code{InstanceOfNode} &  & \\
        \midrule
        \code{BitwiseAndNode} &  & \\
        \code{BitwiseOrNode} &  & \\
        \code{BitwiseXorNode} &  & \\
        \code{BitwiseComplementNode} &  & \\
        \midrule
        \code{ConditionalAnd} &  & \\
        \code{ConditionalNot} &  & \\
        \midrule
        \code{Cast} & Type cast. & \\
        \code{Unboxing} & Unboxing of an object to a primitive. & \\
        \code{Boxing} & Boxing of a primitive. & \\
        \code{WideningConversion} & Widening of a primitive. & \\
        \code{NarrowingConversion} & Narrowing of a primitive. & \\
        \midrule
        \code{ArrayCreation} &  & \\
        \code{ObjectCreation} & Instantiation of a class. & \\
        \code{AnonymousObjectCreation} & Instantiation of an anonymous class. & \\
        \midrule
        \code{MethodInvocation} &  & \\
        \code{Assert} &  & \\
        \code{Break} &  & \\
        \code{Continue} &  & \\
        \code{Throw} &  & \\
        \code{SynchronizedEntry} &  & \\
        \code{SynchronizedExit} &  & \\
        \code{Return} &  & \\
        \caption{All node types in our dataflow framework.}
        \label{tab:nodes}
    \end{longtable}
    



\subsection{Noteworthy Translations and Node Types}
\label{sec:noteworthy-translations}

In this section we mention any non-straightforward translations from the AST to
the CFG, or special properties about individual nodes.


\subsubsection{Program Structure}

Java programs are structured using high-level programming constructs such as
different variants of loops, if-then-else constructs, try-catch-finally blocks
or switch statements.  During the translation from the AST to the CFG some
of this program structure is lost and all non-sequential control flow is
represented by two low-level constructs: conditional basic blocks and exceptional
control flow edges. For instance, a \code{while} loop is translated
into its condition followed by a conditional basic block that models the two
possible outcomes of the condition: either, the control flow follows the
`true' branch and continues with the loops body, or goes to the `false'
successor and executes the first statement after the loop.

This translation of the many high-level constructs to only few low-level
elements has the advantage that the implementer of a particular dataflow
analysis will not have to think about how all these high-level constructs
behave. In particular, there is usually no need to handle different high-level
constructs in a special manner. However, the loss of the program structure
also means that a dataflow analysis cannot easily (if at all) implement special behavior
for a specific high-level construct. If this becomes a problem in the future,
it is possible to extends the dataflow framework to keep this information.



\subsubsection{Assignment}

As described in \jlsref{15.26.1}, the execution of an assignment is in general
not strictly left-to-right. Rather, the right-hand side might be evaluated even
if the left-hand side of the assignment causes an exception. This semantics is faithfully
represented in the CFG produced by our translation.
An example of a field assignment exhibiting this behavior is shown in \autoref{lst:CFGFieldAssignment}.

\flow{FieldAssignment}{Control flow for a field assignment is not strictly
left-to-right (cf.\ \jlsref{15.26.1}),
which is properly handled by our translation.}


\subsubsection{Conditional Expressions}
\label{sec:cond-exp}

The conditional and (\code{&&}, cf. \jlsref{15.23}) and the conditional
or (\code{||}, cf. \jlsref{15.24}) expression are subject to short-circuiting:
if evaluating the left-hand side already determines the result, then the right-hand
side is not evaluated. This semantics is represented in the CFG, and an example
is given in \autoref{lst:CFGConditionalOr}.

To differentiate the paths taken by the execution, given how the conditional or evaluates,
there are two different nodes for the conditional or expression in the AST
(as shown in \autoref{fig:CFGConditionalOr}). However, this is only the case when
two nodes are needed to distinguish execution paths. If the outgoing edges
of the two nodes for the same expression are merged right away, then there is
no need to have a conditional basic block. In such a case, only one
node is introduced. In the visualization, the truth value is indicated in
parentheses after the node type. An example of only a single node is given in
\autoref{lst:CFGConditionalOr2}.

\flow{ConditionalOr}{Example of a conditional or expression (\code{||}) with short-circuiting
and usage of two \code{ConditionalOrNode}'s.}

\flow{ConditionalOr2}{Example of a conditional or expression (\code{||}) with short-circuiting
and usage of only a single \code{ConditionalOrNode}.}


\subsubsection{Implicit \code{this} access}

The Java compiler AST uses the same type (\code{IdentifierTree}) for local variables
and implicit field accesses (where \code{this.} is left out).
To relieve the user of our dataflow framework from manually determining
the two cases, we consistently use \code{FieldAccessNode} for field accesses,
where the receiver might be an \code{ImplicitThisNode}.
For instance, this is shown in the earlier example \autoref{lst:CFGFieldAssignment}.


\subsubsection{Synchronized Methods}

A \code{synchronized} method acquires a monitor before it executes, and it is possible
to desugar methods with the \code{synchronized} modifier to explicitly use
the \code{synchronized} statement (see \jlsref{8.4.3.6}). This desugaring
assures that the user of the framework only needs to handle the
\code{SynchronizedNode} and does not need to check if a method is declared as
\code{synchronized}.


\subsubsection{Compound Assignments}
\label{sec:compound-assignment}

Compound assignments (such as \code{x += 4}) are translated into the correct operation
(e.g., addition) and an assignment. An example of this is shown in \autoref{fig:CFGCompound}.
Note that the left-hand side of the compound expression only appears \emph{once} in the
control flow graph, but is referred to \emph{twice}; once when it is first executed,
and again as the target of the assignment. This models the execution of compound statements
as specified in \jlsref{15.26.2} correctly, where the expression is evaluated only once, but
its ``value'' used twice.

\flow{Compound}{Control flow for a compound assignment.}

\subsubsection{Prefix/Postfix Increments and Decrements}

The postfix increment and decrement operation cannot easily be translated to a sequence of
assignments and additions/subtractions as was possible with compound assignment (cf.\ \autoref{sec:compound-assignment}).
The problem is that the \emph{old} value of the variable is returned, which cannot easily be modeled
in the given framework. For this reason, the node types \code{PostfixIncrementNode} and
\code{PostfixDecrementNode} are used.

While the same translation as with compound assignments would be possible for
prefix increment/decrement operations, we currently do not perform this translation for uniformity with
the corresponding postfix operation.




\subsection{AST to CFG Translation}

In this section we give a high level overview of the translation process from the
abstract syntax tree to the control flow graph as described in \autoref{sec:cfg-formal}.

First, we define several entities, which will be used in the translation.

\begin{definition}[Extended Node]
    In the translation process the data type \emph{extended node} is used.
    An extended node can be one of four possibilities:
    \begin{itemize}
        \item \textbf{Simple extended node.} An extended node can just be a wrapper for a node
        as defined in \autoref{def:node}.
        \item \textbf{Exception extended node.} Similar to a simple node, an exception extended
        node contains a node, but this node might throw an exception at runtime.
        \item \textbf{Unconditional jump.} An unconditional jump indicates that control
        flow proceeds non-sequential to a location indicated by a target label.
        \item \textbf{Conditional jump.} A conditional jump can follow an extended node
        that contains a node of boolean type. It contains two target labels, one if the
        node evaluates to true and one for false.
    \end{itemize}
\end{definition}
\begin{definition}[Label]
    A \emph{label} is a marker that is used to refer to extended nodes.
\end{definition}

The process of translating an AST to a CFG proceeds in three distinct phases.
\begin{enumerate}
    \item \textbf{Phase one.} In the first phase, a sequence of extended nodes is created
    that represents the control flow of the method. The control flow is implicitly
    assumed to be sequential through the sequence of extended nodes, until a (conditional
    or unconditional) jump is encountered, in which case the jump target decides
    where execution proceeds.
    
    The labels used as targets of jumps are associated with positions in this sequence and are managed
    by maintaining a binding function from labels to sequence positions. The advantage of
    having this indirection is that one can create a label and associate with the next free
    position in the sequence, without knowing which exact extended node will be placed there.
    Furthermore, labels can be created and used before they are actually bound to their correct
    position in the sequence (e.g., when that position is not yet known).
    At the end, the binding function can be used to resolve labels to
    extended nodes.
    
    Furthermore, phase one also computes a mapping from AST tree elements to nodes, as well
    as a set of leaders. A \emph{leader} is an extended node for which one of the following
    condition applies:
    \begin{itemize}
    \item It is the first extended node in the sequence.
    \item It is the target of a jump (i.e. there is a label bound to the location of the node
    in the sequence).
    \item It is the first node following a jump.
    \end{itemize}
    
    \item \textbf{Phase two.} Phase two translates the linear representation to a control flow graph
    by performing the following transformations:
    \begin{itemize}
        \item Simple extended nodes are translated to regular basic blocks, where multiple nodes
        can be grouped in one regular basic block.
        \item Exception extended nodes are translated to exception basic blocks with the correct edges.
        \item Unconditional jumps are replaced with edges between the correct basic blocks.
        \item Conditional jumps are replaced by a conditional basic block.
    \end{itemize}
    To greatly simplify the implementation, phase two is allowed to produce a degenerated control flow
    graph. In particular, the following deficiencies are possible:
    \begin{itemize}
    \item Regular basic blocks might be empty.
    \item Some conditional basic blocks might be unnecessary, in that they have the same target for both
    the `then' as well as the `else' branch.
    \item Two consecutive, non-empty, regular basic blocks can exist, even if the second block has only
    exactly one predecessor and the two block could thus be merged.
    \end{itemize}
    \item \textbf{Phase three.} In the third and last phase, the control flow graph is transformed such that
    the deficiencies remaining from phase two are removed. It is ensured that removing one kind of deficiency
    does not create another degenerate case.
\end{enumerate}






\section{Dataflow Analysis}

In this section, we describe how the dataflow analysis over the control
flow graph is performed and what the user of our framework has to implement to
define a particular analysis.


\subsection{Overview}

Roughly, a dataflow analysis in our framework works as follows. Given the abstract syntax
tree of a method, the framework computes the corresponding control flow graph as
described in \autoref{sec:cfg}. Then, a simple iterative algorithm is used to compute
a fix-point, by iteratively applying a set of transfer functions to the nodes in the
CFG. These transfer functions are specific to the particular analysis and are used
to approximate the runtime-behavior of different statements and expressions.

So-called \emph{stores} are used to keep track of the current information the dataflow
analysis has accumulated. Every store is associated with a particular point in the
control flow graph, and all stores are managed by the framework. It maintains
a single store for every basic block that represents the information available at the
beginning of that block.

The class \code{Analysis<S, T>} (parameterized by the type \code S of the store and the type \code T of the
transfer function) performs the actual dataflow analysis. It requires the transfer function
as an argument to the constructor. Then, the object provides a method to perform the dataflow
analysis on a given control flow graph and methods to query the result of that dataflow analysis.

\begin{workinprogress}
    The querying of information is not implemented yet but is expected to be straight-forward.
\end{workinprogress}




\subsection{Answering Questions}

After the flow analysis for a particular method has been computed, the resulting information
which is maintained in various stores can be queried to answer questions. The implementor
of the dataflow analysis can implement arbitrary queries and how to answer them
given a store. Then, the framework will allow to issue those queries for
any given AST node by looking up (or computing) the correct store and applying the query
implementation.
The store may first need to be computed, as the framework does not store all intermediate
stores but rather only those for key positions as described in \todo{ref}.

Examples of common questions include the following.
\begin{itemize}
    \item After execution of the AST node \code{exp}, what is the most
    specific type that can be given to \code{exp} (as determined by the flow analysis).
    \begin{workinprogress}
    This operation has previously been supported by the \code{test} method
    of the interface \code{Flow}.
    \end{workinprogress}
    \item Are all non-null fields of an object initialized to a non-null value
    after a given AST node?
\end{itemize}

To support such queries, our framework builds a map from AST tree nodes (of type
\code{com.sun.source.tree.Tree}) to CFG nodes. Furthermore, every node has a reference
to the basic block it is part of. Thus, for a given AST tree node, the framework
can determine the CFG node and thereby the CFG basic block, and compute the necessary store
to answer the question.

\subsection{Managing Intermediate Results of the Analysis}

Every analysis has to implement the \code{Store} interface. A \emph{store} is
used to track the intermediate results of a dataflow analysis. For instance, the store
could contain information about which expressions can be considered \code{@NonNull}.
A store is required to provide the following operations:
\begin{itemize}
\item Least upper bound: Compute the least upper bound of two stores (e.g., at a merge-point
in the control flow graph).
\item Equivalence: Compare two stores if they are (semantically) different, which is used
to determine if a fix-point is reached in the dataflow analysis. Note that reference-equality
is most likely not sufficient.
\item Copy mechanism: Clone stores to get an exact copy.
\end{itemize}
The store is analysis-dependent, but the framework provides a default store implementation
which can be reused.
This default implementation keeps a map of \code{Node}'s to abstract values, and various means
to interact and change these values (such as correctly handling aliasing, etc.).

\begin{workinprogress}
    This default store is not yet implemented, but a simpler approximation is used in the
    constant propagation example (see below).
\end{workinprogress}



\subsection{Transfer Function}

A transfer function has to provide the following:
\begin{itemize}
\item A method that returns the initial store to be used by the dataflow analysis, given
the list of arguments (as \code{LocalVariableNode}'s) and the \code{MethodTree} (not expected to be used).
\item A transfer method for every \code{Node} type that takes a store, the node and produces
an updated store. This is achieved by implementing the \code{NodeVisitor<S, S>} interface
for the store type \code{S}.
\end{itemize}

To allow the dataflow analysis to use different information (that is, different stores)
for conditional nodes and its two successors, it is possible to provide two additional
transfer functions; one for the \emph{true} edge and one for the \emph{false} edge.
That is, there are potentially three transfer functions; one regular transfer function, and two
for conditional basic blocks.


\section{Example: Constant Propagation}

\begin{workinprogress}
    As a proof-of-concept, I implemented a constant propagation analysis for local variables
    and integer values. I describe the most important aspects here.
    
    \textbf{Abstract values.} A class \code{Constant} is used as an abstract value, which can
    either be \emph{top} (more than one integer value seen), \emph{bottom} (no value seen yet),
    or \emph{constant} (exactly one value seen; in which case the value is also stored).
    
    \textbf{The store.} The store for the constant propagation analysis maps \code{Node}'s to \code{Constant},
    where only \code{LocalVariableNode}'s and \code{IntegerLiteralNode}'s are actually stored. Only those
    two nodes actually are of interest (there is no addition/multiplication/etc. yet, and other constructs like
    fields are not supported by the analysis).
    
    Two different instances of \code{LocalVariableNode} can refer to the same local variable, and thus
    the \code{equals} method has been implemented accordingly. Therefore, every local variable occurs
    at most once in the store, even if multiple \code{LocalVariableNode} for it exist.
    
    \textbf{The transfer function.} The transfer function is very simple. The initial store contains
    \emph{top} for all parameters, as any value could have been passed in. Then, for
    an integer literal, the store is extended with the information what abstract value this literal
    stands for. Furthermore, for an assignment I check if the left-hand side is
    a local variable, and if so update its abstract value in the
    store with the abstract value of the right-hand side (which can be looked up in the store).
    
    To illustrate how we can have different information in the then and else block of a conditional,
    I also implemented another transfer function that considers the \code{EqualToNode}, and if
    it is of the form \code{a == e} for a local variable \code{a} and constant \code{e}, passes
    the correct information to one of the branches. This is also shown in the example of \autoref{fig:ConstSimple}.
    
    \text{Example.} A small example is shown in \autoref{fig:ConstSimple}.
\end{workinprogress}

\constantpropagation{Simple}{Simple sequential program to illustrate constant propagation.}


\section{Default Analysis}

\subsection{Overview}

The default flow-sensitive analysis works for the qualifier hierarchy of any checker defined in 
the Checker Framework.  This generality is both a strength and a weakness because the 
default analysis can
always run but the facts it can deduce are limited.  The default analysis
will be extensible so checkers can add logic specific to their own qualifiers.

The default flow-sensitive analysis tracks type annotations though assignments to local 
variables and thereby improves precision when the qualifiers on the right hand side of the
assignment are more precise than those on the left hand side.

The analysis relies on an \code{AnnotatedTypeFactory} to supply the flow-insensitive type 
annotations on an AST \code{Tree} and it relies on a \code{QualifierHierarchy} to define the 
subtype relationships 
among annotations.  It enforces the invariant that flow-sensitive type annotations are always at 
least as precise as flow-insensitive ones.

\begin{workinprogress}
The default analysis should, but does not yet, propagate types through AST expressions. 
Consider an example where two variables declared as \code{Strings} are concatenated and the
analysis determines that both are \code{@Regex Strings} at the concatenation.  The analysis 
should determine that the result is a \code{@Regex String} too.  Notice that the need to propagate
types through expressions is not specific to flow-sensitive analysis.  It should work the same way 
when flow-insensitive inference determines that two \code{@Regex Strings} are 
concatenated.  We should make sure that checker developers only have to specify
type propagation rules once but get the benefit everywhere.
\end{workinprogress}

The default analysis uses a simple \code{Store} that maps \code{Nodes} to sets of 
\code{AnnotationMirrors}. 
The \code{Nodes} can be divided into two types.  \code{VariableDeclarationNodes} 
represent mutable 
values so their mappings can vary across the \code{Stores} at different program points.  All other 
\code{Nodes} are immutable because they correspond to AST \code{Trees} with at most 
one consumer. 
We still explicitly represent such \code{Nodes}, but there is a potential space optimization to be
had by leaving them out of the \code{Store} after processing their consumer.


\subsection{Implementation}

A few of the implementation details of the default analysis are worth discussing.

Since the flow-insensitive annotations for a \code{Node} are an upper bound on the flow-sensitive 
annotations, we don't need to explicitly keep the annotations in the Store unless they are more
precise than the flow-insensitive ones.  The \code{BaseTypeAnalysis.NodeInfo} class returns
information from the \code{Store} when it is present and defaults to the 
\code{AnnotatedTypeFactory} when none is present.

A potential optimization that is not yet implemented is to delete \code{Nodes} from the 
\code{Store} after
their last use.  As mentioned above, since the CFG derives from an AST and we never 
transform it, \code{Nodes} that are not variable declarations don't need to be kept after processing 
the \code{Node} 
corresponding to their AST parent.

Each analysis pass implements the \code{AbstractValue}, \code{Store} and 
\code{Transfer} interfaces, so the
default analysis does also.  The current prototype makes those implementations inner
classes within the \code{BaseTypeAnalysis} class, so there is just one (final) member field
for the \code{QualifierHierarchy} and one for the \code{AnnotatedTypeFactory} that determine 
which checker is providing the type information for the analysis.


\subsection{Open Questions}

\begin{workinprogress}
So far, the default analysis only tracks assignments to local variables and not to member
fields.  Because multiple threads could access a field concurrently, we can't treat fields
simply as if they were local variables, but in certain cases we might be able to prove 
they aren't accessed concurrently.  Should we worry about this?  It could be quite expensive 
to prove single-threaded access to fields and the Java spec says that even final fields can be
changed via reflection.  Perhaps this problem is just too hard.

The \code{EqualTo} and \code{NotEqual Nodes} could potentially supply flow-sensitive
information for 
non-primitive types because they establish that two \code{Objects} are identical, which means their 
types are identical.  For example, suppose that \code{s1} is a \code{String} and \code{s2} is 
a \code{@Regex String}.  Then
in the true successor of \code{if (s1 == s2)}, we know that \code{s1} is also a 
\code{@Regex String}.  However, it 
seems inconsistent to extract information from a comparison of objects with distinct types.  
We would most likely issue an error for comparing a \code{String} to a \code{@Regex String}
and expect the
programmer to fix it, so this is a kind of information that may never appear in properly typed
programs.
\end{workinprogress}

















