\htmlhr
\chapter{Frequently Asked Questions (FAQs)\label{faq}}

These are some common questions about the Checker Framework and about
pluggable type-checking in general.  Feel free to suggest improvements to
the answers, or other questions to include here.

There is a separate FAQ for the type annotations syntax
(\url{http://types.cs.washington.edu/jsr308/jsr308-faq.html}).

% Not supported by Hevea, so don't bother; instead do by hand:
% \minitoc

%BEGIN LATEX
~
%END LATEX

\noindent
\textbf{Contents:} \\
\ref{faq-ease-of-use}: Are type annotations easy to read and write? \\
\ref{faq-code-clutter}: Will my code become cluttered with type annotations? \\
\ref{faq-no-absolute-guarantee}: Can a pluggable type-checker give an absolute guarantee of correctness? \\
\ref{never-make-type-errors}: I don't make type errors, so would pluggable type checking help me? \\
\ref{faq-qualifiers-vs-subclasses}: When should I use type qualifiers, and when should I use subclasses? \\
\ref{faq-no-annotation-on-types-and-declarations}: Why shouldn't a qualifier apply to both types and declarations? \\
\ref{faq-run-on-all-files}: How do I run a checker on all my source files? \\
\ref{faq-create-a-checker}: How do I create a new checker? \\
\ref{faq-declarative-syntax-for-type-rules}: Why is there no declarative syntax for writing type rules? \\
\ref{faq-type-checking-vs-bug-detectors}: Why not just use a bug detector (like FindBugs)? \\
\ref{faq-jml}: How does pluggable type-checking compare with JML? \\
\ref{faq-list-map-nonnull-typeargs}: Why are the type parameters to \<List> and \<Map> annotated as \<@NonNull>? \\
\ref{faq-run-time-checking}: How can I do run-time monitoring of properties that were not statically checked?



% This FAQ also appears in the JSR 308 FAQ.
\section{Are type annotations easy to read and write?\label{faq-ease-of-use}}

The paper
\ahref{http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008-abstract.html}{``Practical
  pluggable types for Java''}~\cite{PapiACPE2008} discusses case studies in
which programmers
found type annotations to be natural to read and write.  The code
continued to feel like Java, and the type-checking errors were easy to
comprehend and often led to real bugs.

You don't have to take our word for it, though.  You can try the
Checker Framework for yourself.

The difficulty of adding and verifying annotations depends on your program.
If your program is well-designed and -documented, then skimming the
existing documentation and writing type annotations is extremely easy.
Otherwise, you may find yourself spending a lot of time trying to
understand, reverse-engineer, or fix bugs in your program, and then just a
moment writing a type annotation that describes what you discovered.  This
process inevitably improves your code.  You must decide whether it is a
good use of your time.  For code that is not causing trouble now and is
unlikely to do so in the future (the code is bug-free, and you do not
anticipate changing it or using it in new contexts), then the
effort of writing type annotations for it may not be justified.


% This FAQ also appears in the JSR 308 FAQ.
\section{Will my code become cluttered with type annotations?\label{faq-code-clutter}}

As with any language feature, it is possible to write ugly code that
over-uses annotations.  However, in normal use, very few annotations need
to be written.  Figure 1 of the paper
\ahref{http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008-abstract.html}{Practical
  pluggable types for Java}~\cite{PapiACPE2008} reports data for over
350,000 lines of type-annotated code:

\begin{itemize}
\item
    1 annotation per 62 lines for nullness annotations (\<@NonNull>, \<@Nullable>, etc.)
    % (/ (+ 4640 3961 10798) (+ 107 35 167))
\item
    1 annotation per 1736 lines for interning annotations (\<@Interned>)
    % (/ 224048 129)
\item
    1 annotation per 27 lines for immutability annotations (IGJ type system)
    % (/ (+ 6236 18159 30507 8691 59221 26828) (+ 315 1125 1386 384 1815 450))
\end{itemize}

Furthermore, these numbers are for annotating existing code.  New code that
is written with the type annotation system in mind is cleaner and more
correct, so it requires even fewer annotations.

In other words, annotations do not clutter code, and they are used much
less frequently than generic types, which Java programmers find acceptable.


\section{Can a pluggable type-checker give an absolute guarantee of correctness?\label{faq-no-absolute-guarantee}}

Each checker looks for certain errors.  You can use multiple checkers, but
even then your program might still contain other kinds of errors.

If you run a pluggable checker on only part of the code of a program, then
you do not get a guarantee that all parts of the program satisfy the type
system (that is, are error-free).  An example is a framework that clients
are intended to extend.  In this case, you should recommend that clients
run the pluggable checker.  There is no way to force users to do so, so you
may want to retain dynamic checks or use other mechanisms to detect errors.

There are other circumstances in which a static type-checker may fail to
detect a possible type error.  In Java, these include arrays, casts, raw
types, reflection, separate compilation (bytecodes from unverified sources),
native code, etc.  (For details, see section~\ref{checker-guarantees}.)
Java uses dynamic checks for most of these, so that the
type error cannot cause a security vulnerability or a crash.  The pluggable
type-checkers inherit many (not all) of these weaknesses of Java
type-checking, but do not currently have built-in dynamic checkers.
Writing dynamic checkers would be an interesting and valuable project.

% This paragraph is weak.

Even if a tool such as a pluggable checker cannot give an ironclad
guarantee of correctness, it is still useful.  It can finding errors, 
excluding certain types of possible problems (e.g., restricting the
possible class of problems), and increasing confidence in a piece of
software.


\section{I don't make type errors, so would pluggable type checking help me?\label{never-make-type-errors}}

Occasionally, a developer says that he makes no errors that typechecking
could catch, or that any such errors are unimportant because they have low
impact and are easy to fix.  When I investigate the claim, I invariably
find that the developer is mistaken.

Very frequently, the developer has underestimated what typechecking can
discover.  Not every type error leads to an exception being thrown; and
even if an exception is thrown, it may not seem related to classical types.
Remember that a type system can discover
null pointer dereferences,
incorrect side effects, 
security errors such as information leakage or SQL injection,
partially-initialized data,
and many other errors.  Even where type-checking does not discover a
problem directly, it can indicate code with bad smells, thus revealing
problems, improving documentation, and making future maintenance easier.

There are other ways to discover errors, including extensive testing and
debugging.  But type-checking is a good complement to these.  It is more
effective for some problems, and less effective for other problems.  It can
reduce (but not eliminate) the time and effort that you spend on other
approaches.  There are many important errors that type checking and other
automated approaches cannot find; pluggable typechecking gives you more
time to focus on those.


\section{Why shouldn't a qualifier apply to both types and declarations?\label{faq-no-annotation-on-types-and-declarations}}

It is bad style for an annotation to apply to both types and declarations.
In other words, every annotation should have a \<@Target> meta-annotation,
and the \<@Target> meta-annotation should list either only declaration
locations or only type annotations.  (It's OK for an annotation to target
both \<ElementType.TYPE\_PARAMETER> and \<ElementType.TYPE\_USE>, but no
other declaration location along with \<ElementType.TYPE\_USE>.)

Sometimes, it may seem tempting for an annotation to apply to both type
uses and (say) method declarations.  Here is a hypothetical example:

\begin{quote}
  ``Each \<Widget> type may have a \<@Version> annotation.
  I wish to prove that versions of widgets don't get assigned to
  incompatible variables, and that older code does not call newer code (to
  avoid problems when backporting).

  A \<@Version> annotation could be written like so:

\begin{Verbatim}
  @Version("2.0") Widget createWidget(String value) { ... }
\end{Verbatim}

\<@Version("2.0")> on the method could mean that the \<createWidget> method
only appears in the 2.0 version.  \<@Version("2.0")> on the return type
could mean that the returned \<Widget> should only be used by code that
uses the 2.0 API of \<Widget>.  It should be possible to specify these
independently, such as a 2.0 method that returns a value that allows the
1.0 API method invocations.''
\end{quote}

Both of these are type properties and should be specified with type
annotations.  No method annotation is necessary or desirable.  The best way
to require that the receiver has a certain property is to use a type
annotation on the receiver of the method.  (Slightly more formally, the
property being checked is compatibility between the annotation on the type
of the formal parameter receiver and the annotation on the type of the
actual receiver.)


Another example of a type-and-declaration annotation that represents poor
design is JCIP's \<@GuardedBy> annotation~\cite{Goetz2006}.  As discussed
in Section~\ref{jcip-annotations}, it means two different things when
applied to a field or a method.  To reduce confusion and increase
expressiveness, the Lock Checker (see Chapter~\ref{lock-checker}) uses the
\<@Holding> annotation for one of these meanings, rather than overloading
\<@GuardedBy> with two distinct meanings.



\section{When should I use type qualifiers, and when should I use subclasses?\label{faq-qualifiers-vs-subclasses}}

In brief, use subtypes when you can, and use type qualifiers when you cannot
use subtypes.
For more details, see section~\ref{when-to-use-type-qualifiers}.


\section{How do I run a checker on all my source files?\label{faq-run-on-all-files}}

The \code{javac} compiler halts compilation as soon as it processes a
source file with an error, including an error issued by a pluggable
type-checker.  Section~\ref{running} describes the \<-Awarns> command-line
option that turns checker errors into warnings, permitting \<javac> to
continue past the first erroneous source file.


\section{How do I create a new checker?\label{faq-create-a-checker}}

In addition to using the checkers that are distributed with the Checker
Framework, you can write your own checker to check specific properties that
you care about.  Thus, you can find and prevent the bugs that are most
important to you.

Chapter~\ref{writing-a-checker} gives
complete details regarding how to write a checker.  It also suggests places
to look for more help, such as the \ahref{doc/}{Checker Framework
API documentation (Javadoc)} and the source code of the distributed
checkers.

To whet your interest and demonstrate how easy it is to get started, here
is an example of a complete, useful type checker.

\begin{Verbatim}
  @TypeQualifier
  @SubtypeOf(Unqualified.class)
  @Target({ElementType.TYPE_PARAMETER, ElementType.TYPE_USE})
  public @interface Encrypted { }
\end{Verbatim}

Section~\ref{basic-example} explains this checker and tells
you how to run it.


\section{Why is there no declarative syntax for writing type rules?\label{faq-declarative-syntax-for-type-rules}}

A type system implementer can declaratively specify the type qualifier
hierarchy (Section~\ref{declarative-hierarchy}) and the type introduction rules
(Section~\ref{declarative-type-introduction}).  However, the Checker
Framework uses a procedural syntax for specifying type-checking
rules (Section~\ref{extending-visitor}).
A declarative syntax might be more concise, more readable, and more
verifiable than a procedural syntax.

We have not found the procedural syntax to be the most important impediment
to writing a checker.

Previous attempts to devise a declarative syntax 
for realistic type systems have failed; see a technical
paper~\cite{PapiACPE2008} for a discussion.  When an
adequate syntax exists, then the Checker Framework can be extended to
support it.


\section{Why not just use a bug detector (like FindBugs)?\label{faq-type-checking-vs-bug-detectors}}

Pluggable type-checking finds more bugs than a bug detector does, for any
given variety of bug.

A bug detector like \ahref{http://findbugs.sourceforge.net/}{FindBugs}~\cite{HovemeyerP2004,HovemeyerSP2006},
\ahref{http://artho.com/jlint/}{JLint}~\cite{Artho2001}, or
\ahref{http://pmd.sourceforge.net/}{PMD}~\cite{Copeland2005} aims to find \emph{some}
of the most obvious bugs in your program.  It uses a lightweight analysis,
then uses heuristics to discard some of its warnings.  Thus, even if the tool
prints no warnings, your code might still have errors --- maybe the
analysis was too weak to find them, or the tool's heuristics classified the
warnings as likely false positives and discarded them.

A type checker aims to find \emph{all} the bugs (of certain varieties).
It requires you to write type qualifiers in your program, or to use a tool
that infers types.  Thus, it requires more work from the programmer, and in
return it gives stronger guarantees.

Each tool is useful in different circumstances, depending on how important
your code is and your desired level of confidence in your code.  For more
details on the comparison, see section~\ref{other-tools}.  For a case study
that compared the nullness analysis of FindBugs, JLint, PMD, and the
Checker Framework, see section 6 of the paper
\ahref{http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf}{``Practical pluggable types for Java''}~\cite{PapiACPE2008}.


\section{How does pluggable type-checking compare with JML?\label{faq-jml}}

\ahref{http://www.cs.ucf.edu/~leavens/JML/}{JML}, the Java Modeling
Language~\cite{LeavensBR2006:JML}, is a language for writing formal
specifications.  JML aims to be more expressive than pluggable
type-checking.  JML is not as practical as pluggable type-checking.

A programmer can write a JML specification that
describes arbitrary facts about program behavior.  Then, the programmer can
use formal reasoning or a theorem-proving tool to verify that the code
meets the specification.  Run-time checking is also possible.
By contrast, pluggable type-checking can express a more limited set of
properties about your program.

The JML toolset is less mature.  For instance, if your code uses
generics or other features of Java 5, then you cannot use JML.  
However, JML has a run-time checker, which the Checker Framework currently
lacks.


\section{Why are the type parameters to \<List> and \<Map> annotated as \<@NonNull>?\label{faq-list-map-nonnull-typeargs}}

The annotation on \<java.util.Collection> only allows non-null elements:

\begin{Verbatim}
  public interface Collection<E extends @NonNull Object> {
    ...
  }
\end{Verbatim}

\noindent
Thus, you will get a type error if you write code like
\code{Collection<@Nullable Object>}.
A nullable
type parameter is also forbidden for certain other collections, including
\<AbstractCollection>, \<List>, \<Map>, and \<Queue>.

% AbstractCollection has no documentation of its own regarding nullness,
% but it implements Collection.

% The JML specifications of the add() method says
%       @   signals (NullPointerException)
%       @             (* not allowed to add null *);
%       ...
%       @   signals (NullPointerException)
%       @             (* not allowed to add null *);
% In other words, the method might throw NullPointerException, but the JML
% spec does not say under what circumstances.

The \<extends @NonNull Object> bound is a direct consequence of the design
of the collections classes; it merely formalizes the Javadoc specification.
The Javadoc for \<Collection> states:

\begin{quote}
  Some list implementations have restrictions on the elements that they may
  contain. For example, some implementations prohibit null elements, \ldots
\end{quote}

Here are some consequences of the requirement to detect all nullness errors
at compile time.  If even one subclass of a given collection class may
prohibit null, then the collection class and all its subclasses must
prohibit null.  Conversely, if a collection class is specified to accept
null, then all its subclasses must honor that specification.

The Checker Framework's annotations make apparent a flaw in the JDK
design, and helps you to avoid problems that might be caused by that flaw.


\paragraph{Justification from type theory}
Suppose \<B> is a subtype of \<A>.
Then an overriding method in \<B> must have a stronger (or equal) signature
than the overridden method in~\<A>.  In a stronger signature, the formal
parameter types may be supertypes, and the return type may be a subtype.
Here are examples:

\begin{Verbatim}
  class A           {  @NonNull Object Number m1( @NonNull Object arg) { ... } }
  class B extends A { @Nullable Object Number m1( @NonNull Object arg) { ... } } // error!
  class C extends A {  @NonNull Object Number m1(@Nullable Object arg) { ... } } // OK
  class D           { @Nullable Object Number m2(@Nullable Object arg) { ... } }
  class E extends D {  @NonNull Object Number m2(@Nullable Object arg) { ... } } // OK
  class F extends D { @Nullable Object Number m2( @NonNull Object arg) { ... } } // error!
\end{Verbatim}

According to these rules, since some subclasses of \<Collection> do not
permit nulls, then \<Collection> cannot either:

\begin{Verbatim}
  // does not permit null elements
  class PriorityQueue<E> implements Collection<E> {
    boolean add(E);
    ...
  }
  // must not permit null elements, or PriorityQueue would not be not a subtype of Collection
  interface Collection<E> {
    boolean add(E);    
    ...
  }
\end{Verbatim}


\paragraph{Justification from checker behavior}

Suppose that you changed the bound in the \<Collection> declaration to
\<extends @Nullable Object>.  Then, the checker would issue no warning for
this method:

\begin{Verbatim}
  static void addNull(Collection l) {
    l.add(null);
  }
\end{Verbatim}

\noindent
However, calling this method \emph{can} result in a null pointer exception,
for instance caused by the following code:

\begin{Verbatim}
  addNull(new PriorityQueue());
\end{Verbatim}

\noindent
Therefore, the bound must remain as \<extends @NonNull Object>.

By contrast, this code is OK because \<ArrayList> is documented to support
null elements:

\begin{Verbatim}
  static void addNull(ArrayList l) {
    l.add(null);
  }
\end{Verbatim}

\noindent
Any subclass of \<ArrayList> must also support null elements.




% Every implementation of List seems to permit null.
% Examples of Collection that do not permit null:
% BlockingQueue family:
%   BlockingQueue, BlockingDeque, ArrayBlockingQueue, DelayQueue, LinkedBlockingDeque, LinkedBlockingQueue, PriorityBlockingQueue, SynchronousQueue 
% PriorityQueue
% probably lots of other queues.

% A similar argument applies to \<Map>.
% For example, \<ConcurrentHashMap> and \<Hashtable> implement \<Map> but do
% not permit \<null> to be used as a key or value.  Therefore, \<Map> must
% not permit \<null> to be used as a key or value


% The Checker Framework is designed to warn you whenever your code might
% throw a null pointer exception.  If you want to be safe, you will never put
% \<null> in a \<List> of unknown provenance, because that \<List> might not
% accept null.



\paragraph{Suppressing warnings}

Suppose your program has a list variable, and you know that any list referenced
by that variable will definitely support null.  Then, you can suppress the
warning:

\begin{Verbatim}
  @SuppressWarnings("nullness:generic.argument")
  static void addNull(List l) {
    l.add(null);
  }
\end{Verbatim}

\noindent
You need to use \<@SuppressWarnings("nullness:generic.argument")>
whenever you use a collection that may contain \<null> elements in
contradiction to its documentation.  Fortunately, such uses are relatively
rare.


For more details on suppressing nullness warnings, see
Section~\ref{suppressing-warnings-nullness}.


\section{How can I do run-time monitoring of properties that were not statically checked?\label{faq-run-time-checking}}

Currently, the Checker Framework has no support for adding code to check,
at run time, code that was not checked (see
Chapter~\ref{warnings-and-legacy} for reasons that code might not be
checked).  An exception is the Nullness Checker, which has ways to
dynamically check nullness via assertions and casts (the
\refmethod{nullness}{NullnessUtils}{castNonNull}{(T)} method); see
Section~\ref{suppressing-warnings-with-assertions}.

More general support would be an interesting and valuable project.  If you
are able to add run-time verification functionality, we would gladly
welcome it as a contribution to the Checker Framework.


% LocalWords:  IGJ toolset AbstractCollection ConcurrentHashMap NullnessUtils
% LocalWords:  castNonNull createWidget backporting JCIP's GuardedBy Awarns PMD
% LocalWords:  ElementType nullness bytecodes JLint Hashtable SuppressWarnings
