\htmlhr
\chapter{Format String Checker\label{formatter-checker}}

% VERIFICATION
The Format String Checker detects and prevents use of incorrect format strings
in format methods such as 
\sunjavadoc{java/io/PrintStream.html#printf(java.lang.String,java.lang.Object...)}{System.out.printf}
and \sunjavadoc{java/lang/String.html#format(java.lang.String, java.lang.Object...)}{String.format}.
% BUG FINDER
% The Format String Checker helps to prevent bugs that are the result of an
% incorrect use of format methods such as 
% \sunjavadoc{java/io/PrintStream.html#printf(java.lang.String,java.lang.Object...)}{System.out.printf}.

% VERIFICATION

% BUG FINDER
% The Format String Checker helps to prevent bugs in two ways: 
% 
% \begin{itemize}
% \item An error is issued if a format method would fail to execute at
%     runtime.  For example, if an invalid format string is passed.  
% \item A warning is issued for possibly legal but likely unintended uses of a
%     format method. For example, if unused format arguments are passed. 
% \end{itemize}
%
% \noindent
Following are examples of common errors that the Format String Checker detects at
compile time, more details are provided in Section~\ref{formatter-bugs}.

\begin{Verbatim}
    String.format("%d", "String");  // invalid argument for %d
    String.format("%y", 7);         // invalid format string
    String.format("{0}", "String"); // unused argument, {0} is wrong syntax
    String.format("%d", 7, 3);      // unused argument 3
    String.format("%d %s", 7);      // missing argument for %s
\end{Verbatim}

The Format String Checker's most important annotation is
\code{@\refclass{checker/quals}{Format}}. Yet, it is rare that this annotation
has to be written, as it is inferred if a string literal is directly passed as
a format method's first parameter. The Format String Checker's annotations are
explained in Section~\ref{formatter-annotations}.

To run the Format String Checker, supply the \code{-processor
checkers.formatter.FormatterChecker} command-line option to javac. 

\section{Format String Checker annotations\label{formatter-annotations}}

Printf-style formatting is the process of replacing \emph{format specifiers} in
a \emph{format string}. The replacements are taken from a \emph{format argument}
list, and the format specifier determines how the format argument is converted to a
string. The Java standard library provides printf-style formatting in \emph{format methods} such as
\sunjavadoc{java/lang/String.html#format(java.lang.String, java.lang.Object...)}{String.format}
and 
\sunjavadoc{java/io/PrintStream.html#printf(java.lang.String,java.lang.Object...)}{System.out.printf}.
Format specifiers are introduced by a \code{\%} character. For example,
\code{String.format("\%s \%d","str",1)} yields \code{"str 1"}.  \code{"\%s \%d"} is
the format string, \code{"\%s"} and \code{"\%d"} are the format specifiers;
\code{"str"} and \code{1} are format arguments.  All of Java's format
methods use the \sunjavadoc{java/util/Formatter.html}{Formatter} class internally.

The Formatter Checker assigns a qualifier to every term, in addition to the
regular Java type. These qualifiers make up the Format String type system.

The \code{@\refclass{formatter/quals}{Format}} qualifier indicates a
\emph{valid} format string. A format string \code{s} is valid if there exists a
list of format arguments \code{l}, such that \code{String.format(s,l)}
does not throw an exception. 

Passing a valid format string to a format method does not guarantee that the 
invocation will succeed. The format method invocation \code{String.format("\%d","String")}
for example, will fail despite the fact that \code{"\%d"} is valid. Passing
a valid format string to a format method with all format arguments being \code{null}, will
never throw an exception.

The \code{@\refclass{formatter/quals}{Format}} qualifier is parameterized with
a list of conversion categories that impose restricts on the format arguments.
Conversion categories are explained in more detail in
Section~\ref{formatter-categories}.  The type qualifier for \code{"\%d \%f"} is
for example \code{@Format(\{INT, FLOAT\})}.

The following example shows how to use the \code{@Format} annotation to
enforces that the function's parameter is a format string that, when
passed to a format method, requires the first format argument to be ``float like'',
and the second format argument to be ``integer like'':

\begin{Verbatim}
    void print(@Format({FLOAT, INT}) format) {
        System.out.printf(format, 7.8, 7);
    } 

    print("Float %f, Number %d");  // ok
    print("Float %f");             // error
\end{Verbatim}

\noindent All other annotations in the Format String type system are only used
internally and cannot be written in your code.
\code{@\refclass{formatter/quals}{InvalidFormat}} indicates an invalid format
string. The annotation is attached to \code{"\%y"}
for example.  \code{@\refclass{formatter/quals}{FormatBottom}} is assigned to the
\code{null} literal. All other terms are assigned the
\code{@\refclass{formatter/quals}{Unqualified}} qualifier.

\subsection{Conversion Categories\label{formatter-categories}}

A format specifier's conversion component consists of its last, or the last two,
characters. The conversion component of \code{"\%d"} is for example \code{d}.

The format argument used to replace a format specifier, may be restricted 
by the format specifier's conversion component. In the following example, the
format specifier's conversion component \code{d} restricts the first format argument
to be ``integer like'':

\begin{Verbatim}
    String.format("%d", 5);         // ok
    String.format("%d", "String");  // warning
\end{Verbatim}

\noindent Many conversion components enforce the same restrictions. We represent
these restrictions as a set of allowed values called \emph{conversion
category}. The ``integer like'' restriction is for example the conversion
category INT.  The following conversion categories are defined in the
\code{\refclass{formatter/quals}{ConversionCategory}} enumeration:

\begin{description}
\item{GENERAL} imposes no restrictions on a format argument's type. Applicable for
    conversions b, B, h, H, s, S.

\item{CHAR} requires that a format argument represents a Unicode character.
    Specifically, \code{char}, \code{Character}, \code{byte},
    \code{Byte}, \code{short}, and \code{Short} are allowed.
    \code{int} or \code{Integer} are allowed if
    \code{Character.isValidCodePoint(argument)} would return \code{true}
    for the format argument. Applicable for conversions c, C.

\item{INT} requires that a format argument represents an integral type. Specifically,
    \code{byte}, \code{Byte}, \code{short}, \code{Short},
    \code{int} and \code{Integer}, \code{long},
    \code{Long}, and \code{BigInteger} are allowed. Applicable for
    conversions d, o, x, X.  

\item{FLOAT} requires that a format argument represents a floating-point type.  Specifically,
    \code{float}, \code{Float}, \code{double},
    \code{Double}, and \code{BigDecimal} are allowed. Surprisingly, integer
    values are not allowed. Applicable for
    conversions e, E, f, g, G, a, A.
 
\item{TIME} requires that a format argument represents a date or time.
    Specifically, \code{long}, \code{Long}, \code{Calendar}, and
    \code{Date} are allowed.  Applicable for conversions t, T.

\item{UNUSED} imposes no restrictions on a format argument. This is the case if a
    format argument is not used as replacement for any format specifier.
    \code{"\%2\$s"} for example ignores the first format argument. 
    % This conversion category is similar to GENERAL, but does allow objects that
    % throw exceptions in \code{toString} and \code{formatTo}.
\end{description}

\noindent Further, all conversion categories accept \code{null}.
% MAKES SENSE, BUT IS CONFUSING AND NOT REALLY RELEVEVANT
% Unless otherwise noted, do not allow objects whose \code{toString} method throws an exception.
% Objects that implement the \code{Formattable} interface and throw an
% exception in \code{formatTo} are also not allowed.

Until now, we have assumed that the format specifiers simply consume format arguments left to right.
But there are two other ways for a format specifier to select a format argument:

\begin{itemize}
\item One can specify a one-based \emph{index} before a \code{\$} sign. In the
    format string \code{"\%2\$s"} for example, the format specifier selects the
    second format argument.  
\item One can pass the \code{<} \emph{flag} to reference the format argument
    that was used by the previous format specifier. In the format string
    \code{"\%d \%<d"} for example, both format specifiers select the first
    format argument.
\end{itemize}

\noindent The same format argument may serve as replacement for multiple format specifiers. In
this case, the format argument is restricted by multiple conversions, and is therefore the
\emph{intersection} of the associated conversion categories. 

In the following example, the format argument is restricted by CHAR and
INT.  The format argument must therefore be compatible with both conversion
categories, and can therefore neither be a \code{Character} nor \code{Long}.
This particular intersection of conversion categories is called
\code{CHAR\_AND\_INT}:

\begin{Verbatim}
    format("Char %1$c, Int %1$d", (int)42);   // ok
    format("Char %1$c, Int %1$d", (long)42);  // error
\end{Verbatim}
 
\noindent Many of these intersections lead to already existing conversion categories,
for example \code{GENERAL} $\cap$ \code{CHAR} $=$ \code{CHAR} and 
\code{UNUSED} $\cap$ \code{GENERAL} $=$ \code{GENERAL}. But some do not:

\begin{description}
\item{NULL} is used if no object of any type can be
    passed as parameter. In this case, the only legal value is \code{null}.
    The format string \code{"\%1\$f \%1\$c"}, for example requires that the first
    format argument be \code{null}.  Passing a value such as \code{4} or
    \code{4.2} would lead to an exception.
\item{CHAR\_AND\_INT} is used if a format argument is restricted by a \code{CHAR} and \code{INT} conversion category (\code{CHAR} $\cap$ \code{INT}).
\item{INT\_AND\_TIME} is used if a format argument is restricted by an \code{INT} and \code{TIME} conversion category (\code{INT} $\cap$ \code{TIME}).
\end{description}

\noindent All intersections of more than two conversion categories lead to an already
existing conversion category. Figure~\ref{fig:formatter-cat} summarizes the subset 
relationship among all conversion categories.

\begin{figure}[thbp]
    \includeimage{formatter-categories}{2.5cm}
    \caption{The subset relationship among conversion categories.}
    \label{fig:formatter-cat}
\end{figure}

\subsection{Type Hierarchy}

\begin{figure}[thbp]
\includeimage{formatter-hierarchy}{2.5cm}
\caption{The Format String Checker type hierarchy.}
\label{fig:formatter-th}
\end{figure}

\noindent Figure~\ref{fig:formatter-th} summarizes the subtype relation among all type
qualifiers.  

% THIS SHOULD BE IN A MORE GENERAL DESCRIPTION OF THE FRAMEWORK
% \code{@Unqualified} is at the top of the hierarchy, which reduces
% false positives. Among other things, it allows you to pass format strings into
% functions that require a simple String without any qualifiers. The \code{null}
% value is assigned bottom for similar reasons. In the following example, this
% enables us to know that no matter the qualifier of \code{T}, \code{null} can
% always be assigned to it:
% 
% \begin{Verbatim}
%     <T> T f() {
%         return null;
%     }
% \end{Verbatim}

Not shown in the figure are the subtyping rules among \code{@Format} qualifiers
with different conversion categories. It is legal to:

\begin{itemize}
\item use a format string with a weaker (less restrictive) conversion category than required.
\item use a format string with less format specifiers than required, but a warning is issued. 
\end{itemize}

The following example shows the subtyping rules in action:

\begin{Verbatim}
    @Format({FLOAT, INT}) 
    String f;

    f = "%f %d";       // ok
    f = "%s %d";       // ok, %s weaker than %f
    f = "%f";          // warning, last argument ignored
    f = "%f %d %s";    // error, too many arguments
    f = "%d %d";       // error, %d not weaker than %f

    String.format(f, 0.8, 42);
\end{Verbatim}

\section{What does the Format String Checker check\label{formatter-bugs}}

% VERIFICATION
If the Format String Checker issues no errors, it provides the following guarantees:

\noindent I.) The following guarantees hold for every format method invocation:

\begin{enumerate} 
    \item The format method's first parameter (or second if a \sunjavadoc{java/util/Locale}{Locale} is provided) is a valid 
        format string (or \code{null}).
    \item A warning is issued if one of the format string's conversion categories is \code{UNUSED}.
    \item None of the format string's conversion categories is \code{NULL}.
\end{enumerate} 

\noindent II.) If the format arguments are passed to the format method as varargs, the
Format String Checker guarantees the following additional properties:

\begin{enumerate} 
\item No fewer format arguments are passed than required by the format string.
\item A warning is issued, if more format arguments are passed than required by the format string.
\item Every format argument's type satisfies its conversion category's restrictions.
\end{enumerate}

\noindent III.) If the format arguments are passed to the format method as array, 
an warning is issued by the Format String Checker.

\noindent Following are examples for every guarantee:

\begin{Verbatim}
    String.format("%d", 42);                     // ok
    String.format(Locale.GERMAN, "%d", 42);      // ok
    String.format(new Object());                 // error (I 1)
    String.format("%y");                         // error (I 1)
    String.format("%2$s","unused","used");       // warning (I 2)
    String.format("%1$d %1$f", 5.5);             // error (I 3)
    String.format("%1$d %1$f %d", null, 6);      // error (I 3)
    String.format("%s");                         // error (II 1)
    String.format("%s","used","ignored");        // warning (II 2)
    String.format("%c",4.2);                     // error (II 3)
    String.format("%c",(String)null);            // error (II 3)
    String.format("%1$d %1$f",new Object[]{1});  // warning (III)
    String.format("%s",new Object[]{"String"});  // warning (III)
\end{Verbatim}

Unused format arguments issue a warning, as we found them to be a very common source of bugs.
Use a \code{@SuppressWarnings} annotation if you are intentionally ignoring format arguments.

Format arguments that can only be \code{null} issue an error. This means that it
may be impossible to pass a valid format string to a format method without an
error being issued. For example \code{String.format("\%1\$d \%1\$f",null)}. 
If you should ever run into this problem, simply replace the problematic format 
specifier with \code{"null"}. In the example above, this would result in
\code{String.format("null null")}.


% BUG FINDER
% Whenever a format method invocation is found in your code, the Format String
% Checker performs certain checks. If it issues an \emph{error}, the invocation
% will definitely fail at runtime. If a \emph{warning} is issued, the Format
% String Checker detected a common source for errors, and it is very likely that
% the invocation contains a bug. 
% 
% \noindent I.) The following checks are run for every format method invocation. The checks:
% 
% \begin{enumerate} 
% \item Issue an \emph{error}, if the format method's first format argument (or
%     second if a \sunjavadoc{java/util/Locale}{Locale} is provided) is not a
%     \code{String} annotated with the \code{@Format} qualifier. 
% \item Issue a \emph{warning}, if any of the \code{@Format} string's 
%     conversion categories is \code{UNUSED}.
% \end{enumerate} 
% 
% \noindent II.) If the format arguments are passed to the format method as varargs, the
% Format String Checker performs the following additional checks, that:
% 
% \begin{enumerate} 
% \item Issue an \emph{error}, if fewer format arguments are passed than required
%     by the \code{@Format} qualifier.
% \item Issue a \emph{warning}, if more format arguments are passed than required
%     by the \code{@Format} qualifier.
% \item The following checks are performed for every format argument (unless the
%     format argument is the \code{null} literal) and the associated conversion category
%     from the \code{@Format} qualifier. The checks:
%     \begin{enumerate}
%         \item Issue a \emph{warning}, if the conversion category is \code{NULL}.
%         \item Issue a \emph{warning}, if the format argument's type does not satisfy
%             the conversion category's restrictions.
%     \end{enumerate}
% \end{enumerate}
% 
% \noindent III.) If the format arguments are passed to the format method as array, the
% Format String Checker performs the following checks instead, that:
% 
% \begin{enumerate} 
% \item Issue a \emph{warning}, if any of the \code{@Format} string's 
%     conversion categories is \code{NULL} (unless the array is the
%     null-array literal \code{(Object[])null}).
% \end{enumerate} 
% 
% \noindent Following are examples for every check:
% 
% \begin{Verbatim}
%     String.format("%d", 42);                     // ok
%     String.format(Locale.GERMAN, "%d", 42);      // ok (I 1)
%     String.format(new Object());                 // error (I 1)
%     String.format("%y");                         // error (I 1)
%     String.format("%2$s","unused","used");       // warning (I 2)
%     String.format("%s");                         // error (II 1)
%     String.format("%s","used","ignored");        // warning (II 2)
%     String.format("%1$d %1$f", null);            // ok (II 3)
%     String.format("%d", null);                   // ok (II 3)
%     String.format("%1$d %1$f", 4);               // warning (II 3 a)
%     String.format("%c",4.2);                     // warning (II 3 b)
%     String.format("%1$d %1$f",new Object[]{1});  // warning (III 1)
% \end{Verbatim}

\subsection{Limitations}

The Format String Checker helps prevent bugs by detecting, at compile time,
which invocations of format methods will fail. While the Format String Checker
finds most of these invocations, there are cases in which a format method call
will fail even though the Format String Checker issued neither errors nor
warnings. These cases are:

\begin{enumerate}
\item The format string is \code{null}. Use the Nullness Checker to prevent this.
\item A format argument's toString methods throws an exception.
\item A format argument implements the \code{Formattable} interface and throws an
    exception in the \code{formatTo} method.
\item A format argument's conversion category is \code{CHAR} or \code{CHAR\_AND\_INT},
    and the passed value is an \code{int} or \code{Integer}, and 
    \code{Character.isValidCodePoint(argument)} returns \code{false}.
% VERIFICATION
% BUG FINDER
% \item Illegal format arguments are passed as an array (instead of varargs).
\end{enumerate}

\noindent The following examples illustrate these limitations:

% VERIFICATION
\begin{Verbatim}
    class A {
        public String toString() {
            throw new Error();
        }
    }

    class B implements Formattable {
        public void formatTo(Formatter fmt, int f, 
                int width, int precision) {
            throw new Error();
        }
    }

    // the checker issues no errors or warnings for the
    // following illegal invocations of format methods
    String.format(null);          // NullPointerException (1)
    String.format("%s", new A()); // Error (2)
    String.format("%s", new B()); // Error (3)
    String.format("%c", (int)-1); // IllegalFormatCodePointException (4)
\end{Verbatim}

% BUG FINDER
% \begin{Verbatim}
%     class A {
%         public String toString() {
%             throw new Error();
%         }
%     }
% 
%     class B implements Formattable {
%         public void formatTo(Formatter fmt, int f, 
%                 int width, int precision) {
%             throw new Error();
%         }
%     }
% 
%     // the checker issues no errors or warnings for the
%     // following illegal invocations of format methods
%     String.format(null);          // NullPointerException (1)
%     String.format("%s", new A()); // Error (2)
%     String.format("%s", new B()); // Error (3)
%     String.format("%d", new Object[]{4.2}); // IllegalFormatConversionException (4)
%     String.format("%c", (int)-1); // IllegalFormatCodePointException (5)
% \end{Verbatim} 


\section{Implicit qualifiers}

As described in Section~\ref{effective-qualifier}, the Format String Checker adds implicit
qualifiers, reducing the number of annotations that must appear in your code.
The checker implicitly adds the \code{@Format} qualifier with the correct
conversion categories to any String literal that is a valid format string.

\section{Testing if a format string is valid}

% Copied from the Regex Checker

Sometimes, the Format String Checker cannot infer whether a particular
expression is a valid format string. In these cases, you can call the
\refmethod{checker/formatter}{FormatterUtil}{asFormat} 
method to check if the format string is valid, and whether the
format string's format specifiers match certain conversion categories.
If this is not the case, an exception is raised.

The following code, for example, does not type check:

\begin{Verbatim}
    Scanner s = new Scanner(System.in);    
    String format = s.next();
    // ... much later in the code
    System.out.printf(format,"String",1337); 
\end{Verbatim}

\noindent Change it to the following to make it work:

\begin{Verbatim}
    Scanner s = new Scanner(System.in);
    String format = s.next()
    try {
        format = FormatterUtil.asFormat(format,GENERAL,INT); 
    } catch(IllegalFormatException e) {
        System.err.println("The user entered the following invalid format string: "+format);
        return
    }
    // ... much later in the code
    System.out.printf(format,"String",1337); 
\end{Verbatim}

\noindent A potential disadvantage of using the \code{FormatterUtil} class is that your code becomes
dependent on the Checker Framework at run time as well as at compile time. You
can avoid this by adding the Checker Framework to your project, or by copying
the \code{FormatterUtil} class into your own code.
