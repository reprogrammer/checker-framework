\htmlhr
\chapter{Generics and polymorphism\label{polymorphism}}

This chapter describes support for Java generics and for the anologous
capability over type qualifiers.


\section{Generics (parametric polymorphism or type polymorphism)\label{generics}}

The Checker Framework fully supports
type-qualified Java generic types (also known in the research literature as ``parametric
polymorphism'').  Before running any checker, we recommend that you eliminate
raw types from your code (e.g., your code should use \code{List<...>} as
opposed to \code{List}).
Using generics helps prevent type errors just as using a pluggable
type-checker does.
% Should say why, or what are the consequences of violating this.

When instantiating a generic type,
clients supply the qualifier along with the type argument, as in
\code{List<@NonNull String>}.


\subsection{Restricting instantiation of a generic class}

When you define a generic class, the generic type parameters can restrict
how the class may be instantiated.  For example, given the definition
\verb|class G<T extends Number> {...}|,
a client can instantiate it as \code{G<Integer>} but not \code{G<Date>}.
Similarly, type qualifiers on the generic type parameters can restrict on
how the class may be instantiated.  For example, a generic list class may
indicate that it can hold only non-null values.  Similarly, a generic map
class might indicate it requires an immutable key type, but that it
supports both nullable and non-null value types.


There are two ways to restrict the type qualifiers that may be used on
the actual type argument when instantiating a generic class.

The first technique is the standard Java approach of using the
\code{extends} or \code{super} clause to supply an upper or lower bound.
For example:

\begin{Verbatim}
  MyClass<T extends @NonNull Object> { ... }

  MyClass<@NonNull String> m1;       // OK
  MyClass<@Nullable String> m2;      // error
\end{Verbatim}

The second technique is to write a type annotation on the declaration of a
generic type parameter, which specifies the exact annotation that is
required on the actual type argument, rather than just a bound.  For example:

\begin{Verbatim}
  class MyClassNN<@NonNull T> { ... }
  class MyClassNble<@Nullable T> { ... }

  MyClassNN<@NonNull Number> v1;     // OK
  MyClassNN<@Nullable Number> v2;    // error
  MyClassNble<@NonNull Number> v4;   // error
  MyClassNble<@Nullable Number> v3;  // OK
\end{Verbatim}

A way to view a type annotation on a generic type parameter declaration is
as syntactic sugar for the annotation on both the \<extends> and the
\<super> clauses of the declaration.  For example, these two declarations
have the same effect:

\begin{Verbatim}
  class MyClassNN<@NonNull T> { ... }
  class MyClassNN<T extends @NonNull Object super @NonNull void> { ... }
\end{Verbatim}

\noindent
except that the latter is not legal Java syntax.  The syntactic sugar is
necessary because of two limitations in Java syntax:  it is illegal to
specify both the upper and the
lower bound, and it is impossible to specify a type annotation for a lower
bound without also specifying a type (use of \<void> is illegal).

If a type parameter declaration is annotated with \code{@A}, and a bound is
also given, then the annotation applies everywhere that there is no
explicit annotation.  For example, the following pairs of declarations are
identical.

\begin{Verbatim}
  class MyClass<@A T> { ... }
  class MyClass<T extends @A Object super @A void> { ... }

  class MyClass<@A T extends Number> { ... }
  class MyClass<T extends @A Number super @A void> { ... }

  class MyClass<@A T extends @B Number> { ... }
  class MyClass<T extends @B Number super @A void> { ... }

  class MyClass<@A T super Number> { ... }
  class MyClass<T extends @A Object super @A Number> { ... }

  class MyClass<@A T super @B Number> { ... }
  class MyClass<T extends @A Object super @B Number> { ... }
\end{Verbatim}

We can see from the above that almost all of the following types mean
different things:

\begin{Verbatim}
  class MyList1<@Nullable T> { ... }
  class MyList2<@NonNull T> { ... }
  class MyList3<T extends @Nullable Object> { ... }
  class MyList4<T extends @NonNull Object> { ... } // same as MyList2
\end{Verbatim}

\<MyList1> must be instantiated with a nullable type. 
The implementation must be able to consume (store) a null
value and produce (retrieve) a null value.

\<MyList2> and \<MyList4> must be instantiated with non-null type.
The implementation has to account for only non-null values --- it
does not have to account for consuming or producing null.

\<MyList3> may be instantiated either way:
with a nullable type or a non-null type.  The implementation must consider
that it may be instantiated either way --- flexible enough to support either
instantiation, yet rigorous enough to impose the correct constraints of the
specific instantiation.  It must also itself comply with the constraints of
the potential instantiations.

One way to express the difference is by comparing what expressions are
legal in the implementation of the list --- that is, what expressions may
appear in the ellipsis, such as inside a method's body.  Suppose each class
has, in the ellipsis, these declarations:

\begin{Verbatim}
  T t;
  @Nullable T nble;      // Section "Type annotations on a use of a generic type variable", below,
  @NonNull T nn;         // further explains the meaning of "@Nullable T" and "@NonNull T".
  void add(T arg) { ... }
  T get(int i) { ... }
\end{Verbatim}

\noindent
Then the following expressions would be legal, inside a given implementation.
(Compilable source code appears as file
\<checker-framework/checkers/tests/nullness/GenericsExample.java>.)

\begin{tabular}{|l|c|c|c|c|} \hline
                        & MyList1 & MyList2 & MyList3 & MyList4 \\ \hline
  t = null;             & OK      & error   & error   & error   \\ \hline
  t = nble;             & OK      & error   & error   & error   \\ \hline
  nble = null;          & OK      & OK      & OK      & OK      \\ \hline
  nn = null;            & error   & error   & error   & error   \\ \hline
  t = this.get(0);      & OK      & OK      & OK      & OK      \\ \hline
  nble = this.get(0);   & OK      & OK      & OK      & OK      \\ \hline
  nn = this.get(0);     & error   & OK      & error   & OK      \\ \hline
  this.add(t);          & OK      & OK      & OK      & OK      \\ \hline
  this.add(nble);       & OK      & error   & error   & error   \\ \hline
  this.add(nn);         & OK      & OK      & OK      & OK      \\ \hline
\end{tabular}


\medskip

%% This text is not very helpful.
% The
% implementation of \code{MyList2} may only place non-null objects in the
% list and may assume that retrieved elements are non-null.  The
% implementation of \code{MyList3} is similar in that it may only place
% non-null objects in the list, because it might be instantiated as, say,
% \code{MyList3<@NonNull Date>}.  When retrieving elements from the list,
% the implementation of \code{MyList3} must account for the fact that
% elements of \code{MyList3} may be null, because it might be instantiated
% as, say, \code{MyList3<@Nullable Date>}.
The differences are more
significant when the qualifier hierarchy is more complicated than just
\<@Nullable> and \<@NonNull>.


\subsection{Defaults for bounds}
Ordinarily, a type parameter declaration with no extends clause means the
type parameter can be instantiated with any type argument at all.  For
example:

\begin{Verbatim}
  class C<T> { ... }
  class C<T extends Object> { ... }  // identical to previous line
\end{Verbatim}

\noindent
However, instantiation may be restricted if a default qualifier is in
effect (see Section~\ref{defaults}).  For example, the Nullness checker
(Chapter~\ref{nullness-checker}) uses a (configurable) default of
\<@NonNull> (see Section~\ref{null-defaults}).  That means that either
declaration above is interpreted as

\begin{Verbatim}
  class C<T extends @NonNull Object> { ... }
\end{Verbatim}

\noindent
and an instantiation such as \code{C<@Nullable Number>} is illegal.
In such a case, to permit all type arguments, the programmer would write

\begin{Verbatim}
  class C<T extends @Nullable Object> { ... }
\end{Verbatim}


It is possible to set the default qualifier for upper bounds separately
from other default qualifiers, by writing an annotation such as
\<@DefaultQualifier(value="Nullable", locations={DefaultLocation.UPPER\_BOUNDS})>.


\subsection{Type annotations on a use of a generic type variable}

A type annotation on a generic type variable overrides/ignores any type
qualifier (in the same type hierarchy) on the corresponding actual type
argument.  For example, suppose that \code{T} is a formal type parameter.
Then using \code{@Nullable T} within the scope of \code{T} applies the type
qualifier \code{@Nullable} to the (unqualified) Java type of \code{T}.
This feature is only rarely used.

Here is an example of applying a type annotation to a generic type
variable:

\begin{Verbatim}
  class MyClass2<T> {
    ...
    @Nullable T myField = null;
    ...
  }
\end{Verbatim}

\noindent
The type annotation does not restrict how \code{MyClass2} may be
instantiated.  In other words, both
\code{MyClass2<@NonNull String>} and \code{MyClass2<@Nullable String>} are
legal, and in both cases \code{@Nullable T} means \code{@Nullable String}.
In \code{MyClass2<@Interned String>},
\code{@Nullable T} means \code{@Nullable @Interned String}.

% Note that a type annotation on a generic type variable does not act like
% other type qualifiers.  In both cases the type annotation acts as a type
% constructor, but as noted above they act slightly differently.


% %% This isn't quite right because a type qualifier is itself a type
% %% constructor.
% More formally, a type annotation on a generic type variable acts as a type
% constructor rather than a type qualifier.  Another example of a type
% constructor is \code{[]}.  Just as \code{T[]} is not the same type as
% \code{T}, \code{@Nullable T} is not (necessarily) the same type as
% \code{T}.


\section{Qualifier polymorphism\label{qualifier-polymorphism}}

The Checker Framework also supports type \emph{qualifier} polymorphism for
methods, which permits a single method to have multiple different qualified
type signatures.

To \emph{define} a polymorphic qualifier, mark the definition with
\<@\refclass{quals}{PolymorphicQualifier}>.  For example,
\<@\refclass{nullness/quals}{PolyNull}> is a polymorphic type
qualifier for the Nullness type system:

\begin{Verbatim}
  @PolymorphicQualifier
  @Target(ElementType.TYPE_USE)
  public @interface PolyNull { }
\end{Verbatim}

To \emph{use} a polymorphic qualifier, just write it on a type.
For example, you can write \<@PolyNull> anywhere that you would write
\<@NonNull> or \<@Nullable>.

A method written using a polymorphic qualifier conceptually has multiple
versions, somewhat like a template in C++ or the generics feature of Java.
In each version, each instance of the polymorphic qualifier has been
replaced by the same other qualifier from the hierarchy.  See the examples
below in Section~\ref{qualifier-polymorphism-examples}.

The method body must type-check with all signatures.  A method call is
type-correct if it type-checks under any one of the signatures.  If a call
matches multiple signatures, then the compiler uses the most specific
matching signature for the purpose of type-checking.  This is just like
Java's rule for resolving overriding methods, though there is no effect on
run-time dispatch or behavior.

Polymorphic qualifiers can be used on a method signature or body.
They may not be used on classes or fields.

%% I don't see why this is necessarily true; one could define @PolyNull1
%% and @PolyNull2.  It's not so relevant to the manual anyway, and raising
%% the point just makes type system bigots criticize the Checker Framework.
% Qualifier polymorphism is limited to a single qualifier variable per method.


\subsection{Examples of using polymorphic qualifiers\label{qualifier-polymorphism-examples}}

As an example of the use of \<@PolyNull>, method \sunjavadoc{java/lang/Class.html#cast(java.lang.Object)}{Class.cast}
returns null if and only if its argument is \<null>:

\begin{Verbatim}
  @PolyNull T cast(@PolyNull Object obj) { ... }
\end{Verbatim}

\noindent
This is like writing:

\begin{Verbatim}
   @NonNull T cast( @NonNull Object obj) { ... }
  @Nullable T cast(@Nullable Object obj) { ... }
\end{Verbatim}

\noindent
except that the latter is not legal Java, since it defines two
methods with the same Java signature.


As another example, consider

\begin{Verbatim}
  @PolyNull T max(@PolyNull T x, @PolyNull T y);
\end{Verbatim}

\noindent
which is like writing

\begin{Verbatim}
   @NonNull T max( @NonNull T x,  @NonNull T y);
  @Nullable T max(@Nullable T x, @Nullable T y);
\end{Verbatim}

\noindent
Another way of thinking about which one of the two \code{max} variants is
selected is that the nullness annotations of (the declared types of) both
arguments are \emph{unified} to a type that is a supertype of both, also
known as the \emph{least upper bound} or lub.  If both
arguments are \code{@NonNull}, their unification (lub) is \<@NonNull>, and the
method return type is \<@NonNull>.  But if even one of the arguments is \<@Nullable>,
then the unification (lub) is \<@Nullable>, and so is the return type.


\subsection{Use multiple polymorphic qualifiers in a method signature\label{qualifier-polymorphism-multiple-qualifiers}}

%% I can't think of a non-clumsy way to say this.
% Each method containing a polymorphic qualifier is (conceptually) expanded
% into multiple versions completely independently.

Usually, it does not make sense to write only a single instance of a polymorphic
qualifier in a method definition:  if you write one instance of (say)
\<@PolyNull>, then you should use at least two.  (An exception is a
polymorphic qualifier on an array element type; this section ignores that
case, but see below for further details.)

For example, there is no point to writing

\begin{Verbatim}
  void m(@PolyNull Object obj)
\end{Verbatim}

\noindent
which expands to

\begin{Verbatim}
  void m(@NonNull Object obj)
  void m(@Nullable Object obj)
\end{Verbatim}

This is no different (in terms of which calls to the method will
type-check) than writing just

\begin{Verbatim}
  void m(@Nullable Object obj)
\end{Verbatim}

The benefit of polymorphic qualifiers comes when one is used multiple times
in a method, since then each instance turns into the same type qualifier.
Most frequently, the polymorphic qualifier appears on at least one formal
parameter and also on the return type.  It can also be useful to have
polymorphic qualifiers on (only) multiple formal parameters, especially if
the method side-effects one of its arguments.
For example, consider

\begin{Verbatim}
void moveBetweenStacks(Stack<@PolyNull Object> s1, Stack<@PolyNull Object> s2) {
  s1.push(s2.pop());
}
\end{Verbatim}

\noindent
In this example, if it is acceptable to rewrite your code to use Java
generics, the code can be even cleaner:

\begin{Verbatim}
<T> void moveBetweenStacks(Stack<T> s1, Stack<T> s2) {
  s1.push(s2.pop());
}
\end{Verbatim}


%% It would be nice to give an example that isn't too contrived.


\subsection{Using a single polymorphic qualifier on an element type\label{qualifier-polymorphism-element-types}}

There is an exception to the general rule that a polymorphic qualifier
should be used multiple times in a signature.  It can make sense to use a
polymorphic qualifier just once, if it is on an array or generic element
type.

For example, consider a routine that returns the first index, in an array
or collection, of a given element:

\begin{Verbatim}
  public static int indexOf(@PolyNull Object[] a, Object elt) { ... }

  public static int indexOf(Collection<@PolyNull Object> a, Object elt) { ... }
\end{Verbatim}

If \<@PolyNull> were replaced with either \<@Nullable> or \<@NonNull>, then
some safe client calls would be rejected.

Of course, it would be better style to use a generic method, as in either
of these signatures (and likewise for the \<Collection> version):

\begin{Verbatim}
 public static <T> int indexOf(T[] a, /*@Nullable*/ Object elt) { ... }
 public static <T> int indexOf(T[] a, T elt) { ... }
\end{Verbatim}

In conclusion, use of a single polymorphic qualifier may be necessary in
legacy code, but can be avoided by use of better code style.
