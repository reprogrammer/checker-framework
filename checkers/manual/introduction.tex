\section{Introduction\label{introduction}}

The Checker Framework enhances Java's type system to make it more powerful
and useful.
This lets software developers detect and 
prevent errors in their Java programs.

The Checker Framework comes with 6 checkers for specific types of errors:

\begin{enumerate}

\item
  \ahrefloc{nullness-checker}{Nullness checker} for null pointer errors
  (see Section~\ref{nullness-checker})
\item
  \ahrefloc{interning-checker}{Interning checker} for errors in equality
  testing and interning (see Section~\ref{interning-checker})
\item
  \ahrefloc{igj-checker}{IGJ checker} for mutation errors (incorrect
  side effects), based on the IGJ type system (see
  Section~\ref{igj-checker})
\item
  \ahrefloc{javari-checker}{Javari checker} for mutation errors
  (incorrect side effects), based on the Javari type system (see
  Section~\ref{javari-checker})
\item
  \ahrefloc{lock-checker}{Lock checker} for concurrency and lock errors,
  inspired by the Java Concurrency in Practice (JCIP) type system (see
  Section~\ref{lock-checker})
\item
  \ahrefloc{tainting-checker}{Tainting checker} for trust and security errors
  (see Section~\ref{tainting-checker})

\end{enumerate}

\noindent
These checkers are easy to use and are invoked as arguments to \<javac>.


The Checker Framework also enables you to write new checkers of your
own; see Sections~\ref{basic-checker} and~\ref{writing-a-checker}.


\subsection{How it works:  Pluggable types\label{pluggable-types}}

The Checker Framework supports adding
pluggable type systems to the Java language in a backward-compatible way.
Java's built-in typechecker finds and prevents many errors --- but it
doesn't find and prevent \emph{enough} errors.  The Checker Framework lets you
run an additional typechecker as a plug-in to the javac compiler.  Your
code stays completely backward-compatible:  your code compiles with any
Java compiler, it runs on any JVM, and your coworkers don't have to use the
enhanced type system if they don't want to.  You can check only part of
your program, and type inference tools exist to help you annotate your
code.


A type system designer uses the Checker Framework to define type qualifiers
and their semantics, and a
compiler plug-in (a ``checker'') enforces the semantics.  Programmers can
write the type qualifiers in their programs and use the plug-in to detect
or prevent errors.  The Checker Framework is useful both to programmers who
wish to write error-free code, and to type system designers who wish to
evaluate and deploy their type systems.



% This manual is organized as follows.
% \begin{itemize}
% \item Section~\ref{introduction} overviews the Checker Framework and
%   describes how to \ahrefloc{installation}{install} it (Section~\ref{installation}).
% \item Section~\ref{using-a-checker} describes how to \ahrefloc{using-a-checker}{use a checker}.
% \item 
%   The next sections are user manuals for the \ahrefloc{nullness-checker}{Nullness}
%   (Section~\ref{nullness-checker}), \ahrefloc{interning-checker}{Interning}
%   (Section~\ref{interning-checker}), \ahrefloc{javari-checker}{Javari} (Section~\ref{javari-checker}),
%   \ahrefloc{igj-checker}{IGJ} (Section~\ref{igj-checker}), and \ahrefloc{basic-checker}{Basic}
%   (Section~\ref{basic-checker}) checkers.
% \item Section~\ref{annotating-libraries} describes an approach for \ahrefloc{annotating-libraries}{annotating external
% libraries}.
% \item Section~\ref{writing-a-checker} describes how to
%   \ahrefloc{writing-a-checker}{write a new checker} using the Checker Framework.
% \end{itemize}






This document uses the terms ``checker'', ``checker plugin'',
``type-checking compiler plugin'', and ``annotation processor'' as
synonyms.


\subsection{Installation\label{installation}}

This section describes how to install the binary release of the Checker
Framework.  The binary release contains everything that you need, both to
run checkers and to write your own checkers.  As an alternative, the source
release (Section~\ref{install-source}) is useful if you wish to examine or
modify the implementation of checkers or of the framework itself.

% Not "\ahrefurl" because it looks bad in the printed manual.
\textbf{Requirement:} 
You must have \textbf{JDK 6} or later installed.  You can get JDK 6 from 
\ahref{http://java.sun.com/javase/downloads/index.jsp}{Sun}
or elsewhere.  If you are using Apple Mac OS X, you can either use
\ahref{http://developer.apple.com/java/}{Apple's implementation} or
\ahref{http://landonf.bikemonkey.org/static/soylatte/}{SoyLatte}.

For Unix/Linux/MacOS installation instructions, see Section~\ref{unix-installation}.
For Windows installation instructions, see Section~\ref{windows-installation}.



%%% *****
%%% UPDATE
%%% *****

%%% Note that much of this section is duplicated with the "Windows
%%% installation" section.  That is better for users, even though it is
%%% longer and makes the maintainers keep two versions in sync.
\subsubsection{Unix/Linux/MacOS installation\label{unix-installation}}

These instructions assume that you use the bash or sh shell.  If you use a
different shell, you may need to slightly adjust the commands.

\begin{enumerate}

\item
  Download the latest Checker Framework distribution
  % (\ahrefurl{http://types.cs.washington.edu/checker-framework/current/jsr308-checkers.zip})
  and unzip it.  You can put it anywhere you like; a standard place is in a
  new directory named \code{jsr308}.

\begin{Verbatim}
  export JSR308=$HOME/jsr308
  mkdir ${JSR308}
  cd ${JSR308}
  wget http://types.cs.washington.edu/checker-framework/current/jsr308-checkers.zip
  unzip jsr308-checkers.zip
\end{Verbatim}

\item
  The download includes an updated version of the javac compiler, called
  the ``Type Annotations compiler'' or ``JSR 308 compiler'', that will be
  shipped with Java 7.  In order to use the updated compiler when you type
  \code{javac}, add the directory \code{.../checkers/binary} to your path.

  Place the following commands in your \code{.bashrc} file (and also execute
  it on the command line, or log out and back in):
\begin{Verbatim}
  export JSR308=$HOME/jsr308
  export PATH=$JSR308/checkers/binary:${PATH}
\end{Verbatim}

% It is not necessary to add checkers.jar to your classpath, because the
% shipped compiler already does so.
%   export CLASSPATH=$JSR308/checkers/checkers.jar:${CLASSPATH}


\item
  Verify that the installation works.  From the command line, run:

\begin{Verbatim}
  javac -version
\end{Verbatim}

The output should be:

\begin{Verbatim}
  javac 1.7.0-jsr308-0.9.7
\end{Verbatim}

\end{enumerate}

That's all there is to it!  Now you are ready to start using the checkers.

Section~\ref{example-use} walks you through a simple example.  More detailed
instructions for using a checker appear in Section~\ref{using-a-checker}.


\subsubsection{Windows installation\label{windows-installation}}

\begin{enumerate}

\item
  Download the latest Checker Framework distribution
  % (\ahrefurl{http://types.cs.washington.edu/checker-framework/current/jsr308-checkers.zip})
  and unzip it to create a \<checkers> directory.  You can put it anywhere
  you like; a standard place is in a new directory under \<C:\ttbs{}Program
  Files>.

\begin{enumerate}
\item
  Save the file
  \ahrefurl{http://types.cs.washington.edu/checker-framework/current/jsr308-checkers.zip}
  to your Desktop.
\item
  Double-click the \<jsr308-checkers.zip> file on your computer.  Click on
  the \<checkers> directory, then Select \<Extract all files>, and use
  \<C:\ttbs{}Program Files> as the destination.  You will obtain a new
  \<C:\ttbs{}Program Files\ttbs{}checkers> folder.
\end{enumerate}

\item
  The download includes an updated version of the javac compiler, called
  the ``Type Annotations compiler'' or ``JSR 308 compiler'', that will be
  shipped with Java 7.  In order to use the updated compiler when you type
  \code{javac}, add the directory \<C:\ttbs{}Program
  Files\ttbs{}checkers\ttbs{}binary> to your path variable.  Also set a
  CHECKERS variable.

% Instructions stolen from http://www.webreference.com/js/tips/020429.html

To set an environment variable, you have two options:  make the change
temporarily or permanently.
\begin{itemize}
\item
To make the change \textbf{temporarily}, type at the command shell prompt:

\begin{alltt}
path = \emph{newdir};%PATH%
\end{alltt}

For example:

\begin{Verbatim}
path = C:\Program Files\checkers\binary;%PATH%
set CHECKERS = C:\Program Files\checkers
\end{Verbatim}

This is a temporary change that endures until the window is closed, and you
must re-do it every time you start a new command shell.

\item
To make the change \textbf{permanently},
Right-click the \<My Computer> icon and
select \<Properties>. Select the \<Advanced> tab and click the
\<Environment Variables> button. In the \<System Variables> pane, select
\<Path> from the list and click \<Edit>. In the \<Edit System Variable>
dialog box, move the cursor to the beginning of the string in the
\<Variable Value> field and type the full directory name followed by a
semicolon (\<;>).

% This is for the benefit of the Ant task.
Similarly, set the CHECKERS variable.

This is a permanent change that only needs to be done once ever.
\end{itemize}


% It is not necessary to add checkers.jar to your classpath, because the
% shipped compiler already does so.
%   export CLASSPATH=$JSR308/checkers/checkers.jar:${CLASSPATH}

\item
  Verify that the installation works.  From the command line, run:

\begin{Verbatim}
  javac -version
\end{Verbatim}

The output should be:

\begin{Verbatim}
  javac 1.7.0-jsr308-0.9.7
\end{Verbatim}

\end{enumerate}

That's all there is to it!  Now you are ready to start using the checkers.

Section~\ref{example-use} walks you through a simple example.  More detailed
instructions for using a checker appear in Section~\ref{using-a-checker}.



\subsection{Example use:  detecting a null pointer bug\label{example-use}}

To run a checker on a source file, just run javac as usual, passing the
\<-processor> flag.  For instance, if you usually run the compiler like
this:

\begin{Verbatim}
  javac Foo.java Bar.java
\end{Verbatim}

\noindent
then you will instead run it like this (where \<javac> is the JSR 308
compiler that is distributed with the Checker Framework):

\begin{alltt}
  javac -processor \textit{ProcessorName} Foo.java Bar.java
\end{alltt}

\noindent
(If you usually do your coding within an IDE, you will need to configure
the IDE to use the correct version of javac and to pass the command-line
argument.  See your IDE documentation for details.)

\begin{enumerate}
\item
  Let's consider this very simple Java class.  One local variable is
  annotated as \<NonNull>, indicating that \<ref> must be a reference to a
  non-null object.  Save the file as \<GetStarted.java>.

\begin{Verbatim}
import checkers.nullness.quals.*;

public class GetStarted {
    void sample() {
        @NonNull Object ref = new Object();
    }
}
\end{Verbatim}

\item
  Run the nullness checker on the class.  Either run this from the command line:

\begin{Verbatim}
  javac -processor checkers.nullness.NullnessChecker GetStarted.java
\end{Verbatim}

\noindent
or compile from within your IDE, which you have customized to use the JSR
308 compiler and to pass the extra arguments.

  The compilation should complete without any errors.

\item
  Let's introduce an error now.  Modify \<ref>'s assignment to:
\begin{Verbatim}
  @NonNull Object ref = null;
\end{Verbatim}

\item
  Run the nullness checker again, just as before.  This run should emit
  the following error:
\begin{Verbatim}
GetStarted.java:5: incompatible types.
found   : @Nullable <nulltype>
required: @NonNull Object
		@NonNull Object ref = null;
		                      ^
1 error
\end{Verbatim}

The type qualifiers (e.g. \<@NonNull>) are permitted anywhere
that would write a type, including generics and casts; see
Section~\ref{writing-annotations}.

\begin{alltt}
  \underline{@Interned} String intern() \ttlcb{} ... \ttrcb{}             // return value
  int compareTo(\underline{@NonNull} String other) \ttlcb{} ... \ttrcb{}  // parameter
  \underline{@NonNull} List<\underline{@Interned} String> messages;     // non-null list of interned Strings
\end{alltt}

\end{enumerate}


\htmlhr
\section{Using a checker\label{using-a-checker}}

Finding bugs with a checker plugin is a two-step process:

\begin{enumerate}

\item The programmer writes annotations, such as \code{@\refclass{nullness/quals}{NonNull}} and
  \code{@\refclass{interning/quals}{Interned}}, that specify additional information about Java types.
  (Or, the programmer uses an inference tool to automatically insert
  annotations in his code:  see Sections~\ref{nullness-inference} and~\ref{javari-inference}.)
  It is possible to annotate only part of your code:  see
  Section~\ref{unannotated-code}.

\item The checker reports whether the program contains any erroneous code
  --- that is, code that is inconsistent with the annotations.

\end{enumerate}



% The annotations have to be on your classpath even when you are not using
% the -processor, because of the existence of the import statement for
% the annotations.


\subsection{Writing annotations\label{writing-annotations}}

The syntax of type qualifier annotations in Java 7 is specified by
\ahref{http://types.cs.washington.edu/jsr308/}{JSR 308}~\cite{jsr308}.  Ordinary
Java permits annotations on declarations.  JSR 308 permits annotations
anywhere that you would write a type, including generics and casts.  You
can also write annotations to indicate type qualifiers for array levels and
receivers.  Here are a few examples:

\begin{alltt}
  \underline{@Interned} String intern() \ttlcb{} ... \ttrcb{}             // return value
  int compareTo(\underline{@NonNull} String other) \ttlcb{} ... \ttrcb{}  // parameter
  String toString() \underline{@ReadOnly} \ttlcb{} ... \ttrcb{}           // receiver ("this" parameter)
  \underline{@NonNull} List<\underline{@Interned} String> messages;     // generics:  non-null list of interned Strings
  \underline{@Interned} String \underline{@NonNull} [] messages;        // arrays:  non-null array of interned Strings
  myDate = (\underline{@ReadOnly} Date) readonlyObject;     // cast
\end{alltt}

You can also write the annotations within comments, as in
\code{List</*@NonNull*/ String>}.  The Type Annotations compiler, which is
distributed with the Checker Framework, will still process
the annotations.
However, your code will remain compilable by people who are not using the JSR
308 or Java 7 compiler.  For more details, see
Section~\ref{annotations-in-comments}.



\subsubsection{Distributing your annotated project\label{distributing}}

If your code contains any annotations (outside of comments, see Section~\ref{annotations-in-comments}), or any import
statements for the annotations, then your code has a dependency on the
annotation declarations.  You also will need to provide the annotation
declarations as well, if you decide to distribute your project.

For your convenience, inside the the checkers distribution \code{.zip} file
is a jar file,
\code{checkers-quals.jar}, that only contains the distributed qualifiers.
You may include the jar file in your distribution.

Your clients need to have the annotations jar in the classpath when
compiling your project.  When running it though, they most likely
don't require the annotations declarations (unless the annotation
classes are loaded via reflection, which would be unusual).


\subsection{Running a checker\label{running}}

To run a checker plugin, run the compiler \code{javac} as usual,
but pass the \code{-processor \emph{plugin\_class}} command-line
option.
(You might run the compiler from the command line as shown below, or your
IDE might run the javac command on your behalf, in which case see the IDE
documentation to learn how to customize it.)
Remember that you must be using the
Type Annotations version of \<javac>, which you already installed (see Section~\ref{installation}).

Two concrete examples (using the Nullness checker) are:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  javac -processor checkers.nullness.NullnessChecker MyFile.java
  javac -processor checkers.nullness.NullnessChecker -sourcepath checkers/jdk/nullness/src MyFile.java
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\noindent
For a discussion of the \code{-sourcepath} argument, see
Section~\ref{skeleton-using}.

The checker is run only on the Java files specified on the command line (or
created by another annotation processor).
The checker does not analyze other classes (e.g., pre-compiled classes, or
classes whose source
code is available on the classpath), but it does check
the \emph{uses} of those classes in the source code being compiled.

The javac compiler halts compilation as soon as an error is found in a
source file.  You can pass \code{-Awarns} in the command-line to
treat checker errors as warnings.  This option allows you to see all
the type-checking errors at once, rather than just the errors in the first
file that contains errors.

You can always compile the code without the \code{-processor}
command-line option, but in that case no checking of the type
annotations is performed.  The annotations are still written to the
resulting \<.class> files, however.


\subsubsection{Checker auto-discovery}

``Auto-discovery'' makes the \code{javac} compiler always run a checker
plugin, even if you do not explicitly pass the \code{-processor}
command-line option.  This can make your command line shorter, and ensures
that your code is checked even if you forget the command-line option.

To enable auto-discovery, place a configuration file named
\code{META-INF/services/javax.annotation.processing.Processor}
in your classpath.  The file contains the names of the checker plugins to
be used, listed one per line.  For instance, to run the Nullness and the
Interning checkers automatically, the configuration file should contain:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  checkers.nullness.NullnessChecker
  checkers.interning.InterningChecker
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

You can disable this auto-discovery mechanism by passing the
\code{-proc:none} command-line option to \<javac>.

%% Auto-discovering all the distributed checkers by default would be
%% problematic.  So, leave it up to the user to enable auto-discovery.
%%  1. We don't want to auto-discover both the Javari & IGJ type checkers,
%%     as then the user would see multiple, possibly contradictory, types
%%     of mutability diagnostics.
%%  2. The nullness and mutability checkers would issue lots of errors for
%%     unannotated code, and that would be irritating.



\subsubsection{Ant task\label{ant-task}}

If you use the \ahref{http://ant.apache.org/}{Ant} build tool to compile
your software, then you can add an Ant task that runs a checker.  We assume
that your Ant file already contains a compilation target that uses the
\code{javac} task.

First, set the \code{jsr308javac} property:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  <!-- Boilerplate to set jsr308javac property. Is there a better way? -->
  <property environment="env"/>
  <condition property="isUnix">
    <os family="unix" />
  </condition>
  <condition property="isWindows">
    <os family="windows" />
  </condition>
  <target name="init-jsr308javac-unix" if="isUnix">
    <property name="jsr308javac" value="${env.CHECKERS}/binary/javac" />
  </target>
  <target name="init-jsr308javac-windows" if="isWindows">
    <property name="jsr308javac" value="${env.CHECKERS}/binary/javac.bat" />
  </target>
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\noindent
The \code{property} target makes environment variables (such as your home
directory) available to Ant.

Next, duplicate the compilation target, then modify it slightly as
indicated in this example, filling in each ellipsis (\ldots) from the
original compilation target:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  <target name="check-nullness"
          description="Check for nullness errors."
          depends="clean,...,init-jsr308javac-unix,init-jsr308javac-windows">
    <javac ...
           fork="yes"
           executable="${jsr308javac}">
      <compilerarg value="-version"/>
      <compilerarg line="-target 5"/>
      <compilerarg line="-processor checkers.nullness.NullnessChecker"/>
      <compilerarg line="-sourcepath ${env.CHECKERS}/jdk/nullness/src"/>
      <compilerarg value="-implicit:class"/>
      <classpath>
        <pathelement location="${env.annotations}/checkers/checkers.jar"/>
        ...
      </classpath>
      ...
    </javac>
  </target>
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

In the example, the target is named \code{check-nullness}, but you can
name it whatever you like.

The target assumes the existence of a \code{clean} target that removes all
\code{.class} files.  That is necessary because Ant's \code{javac} target
doesn't re-compile \code{.java} files for which a \code{.class} file
already exists.

The \code{executable} and \code{fork} fields of the \code{javac} task
ensure that an external javac program is called.  Otherwise, Ant will run
javac via a Java method call, and there is no guarantee that it will get
the JSR 308 version that is distributed with the Checker Framework.

The \code{-version} compiler argument is just for debugging; you may omit
it.

The \code{-target 5} compiler argument is optional, if you use Java 5 in
ordinary compilation when not performing pluggable type-checking.

The \code{-processor ...} compiler argument indicates which checker to
run.  You can supply additional arguments to the checker as well.

The \code{-implicit:class} compiler argument causes annotation processing
to be performed on implicitly compiled files.  (An implicitly compiled file
is one that was not specified on the command line, but for which the source
code is newer than the \code{.class} file.)  This is the default, but
supplying the argument explicitly suppresses a compiler warning.


\subsubsection{Maven plugin\label{maven-task}}

Adam Warski has written a Maven2 plugin that runs a checker.
The plugin is available at 
\myurl{http://www.warski.org/checkersplugin.html}.


\subsubsection{Intellij IDEA\label{intellij}}

IntelliJ IDEA (Maia release)
\ahref{http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/}{supports}
the Type Annotations (JSR-308) syntax.

http://blogs.jetbrains.com/idea/2009/07/type-annotations-jsr-308-support/

\subsubsection{Eclipse\label{eclipse}}

There are two ways to run a checker from within the Eclipse IDE:  via Ant
or using an Eclipse plug-in.


\paragraph{Using an Ant task}

Add an Ant target as described in Section~\ref{ant-task}.  You can
run the Ant target by executing the following steps
(instructions copied from
\myurl{http://www.eclipse.org/documentation/?topic=/org.eclipse.platform.doc.user/gettingStarted/qs-84_run_ant.htm}):

\begin{enumerate}

\item
  Select \code{build.xml} in one of the navigation views and choose
  {\bf Run As $>$ Ant Build...} from its context menu.

\item
  A launch configuration dialog is opened on a launch configuration
  for this Ant buildfile.

\item
  In the {\bf Targets} tab, select the new ant task (e.g., check-interning).

\item
  Click {\bf Run}.

\item
  The Ant buildfile is run, and the output is sent to the Console view.

\end{enumerate}

\paragraph{Eclipse plug-in}

A prototype Eclipse plug-in for running a checker is available at
\myurl{http://types.cs.washington.edu/checker-framework/eclipse/}.  
The website contains instructions for installing and using the plug-in.
The plug-in is
experimental now, but some people have used it successfully (and we have fixed
all bugs that have been reported so far).


\subsubsection{tIDE}

tIDE, an open-source Java IDE, supports the Checker Framework.  See its
documentation at \myurl{http://tide.olympe-network.com/}.


\subsection{What the checker guarantees\label{checker-guarantees}}

A checker can guarantee that a particular property holds throughout the
code.  For example, the Nullness checker (Section~\ref{nullness-checker})
guarantees that every expression whose type is a \code{@\refclass{nullness/quals}{NonNull}} type never
evaluates to null.  The Interning checker (Section~\ref{interning-checker})
guarantees that every expression whose type is an \code{@\refclass{interning/quals}{Interned}} type
evaluates to an interned value.  The checker makes its guarantee by
examining every part of your program and verifying that no part of the
program violates the guarantee.

There are some limitations to the guarantee.

\begin{itemize}

\item
  Native methods and reflection can behave in a manner that is impossible
  for a compiler plugin to check.  Such constructs may violate the
  property being checked.  Similarly, deserialization and cloning can
  create objects that could not result from normal constructor calls, and
  that therefore may violate the property being checked.

\item 
  A compiler plugin can check only those parts of your program that you run
  it on. If you compile some parts of your program without the
  \code{-processor} switch or with the \code{-AskipClasses} property
  (in other words, without running the checker), or if you use the
  \code{@SuppressWarnings} annotation to suppress some errors or warnings,
  then there is no guarantee that the entire program satisfies the property
  being checked.  An analogous situation is using an external library that
  was compiled without being checked by the compiler plugin.

\item 
  Your code should pass the Java compiler without errors or warnings.  In
  particular, your code should use generic types, with no uses of raw types.
  Misuse of generics, including casting away generic types, can cause other
  errors to be missed.

\item
  \urldef{\jlsintersectiontypesurl}{\url}{http://java.sun.com/docs/books/jls/third_edition/html/typesValues.html#4.9}
  The Checker Framework does not yet support annotations on intersection
  types (see
  \ahref{\jlsintersectiontypesurl}{JLS \S4.9}).  As a result, checkers cannot provide guarantees about
  intersection types.

\item
  Specific checkers may have other limitations; see their documentation for
  details.

\end{itemize}

A checker can be useful in finding bugs or in verifying part of a
program, even if the checker is unable to verify the correctness of an
entire program.

If you find that a checker fails to issue a warning that it
should, then please report a bug (see Section~\ref{reporting-bugs}).


\subsection{Tips about writing annotations\label{tips-about-writing-annotations}}

\subsubsection{Annotations indicate normal behavior\label{annotate-normal-behavior}}

You should use annotations to indicate \emph{normal} behavior.  The
annotation indicate all the values that you \emph{want} to flow to
reference --- not every value that might possibly flow there if your
program has a bug.

Many methods are guaranteed to throw an exception if they are passed \code{null}
as an argument.  Examples include

\begin{Verbatim}
  java.lang.Double.valueOf(String)
  java.lang.String.contains(CharSequence)
  org.junit.Assert.assertNotNull(Object)
  com.google.common.base.Preconditions.checkNotNull(Object)
\end{Verbatim}

\code{@Nullable} might seem like a reasonable annotation for the parameter,
for two reasons.  First, \code{null} is a legal argument with a
well-defined semantics:  throw an exception.  Second, \code{@Nullable}
describes a possible program execution:  it might be possible for
\code{null} to flow there, if your program has a bug.

% (Checking for such a bug is the whole purpose of the \code{assertNotNull}
% and \code{checkNotNull} methods.)

However, it is never useful for a programmer to pass \code{null}.  It is
the programmer's intention that \code{null} never flows there.  If
\code{null} does flow there, the program will not continue normally.

Therefore, you should mark such parameters as \code{@NonNull}, indicating
the intended use of the method.  When you use the \code{@NonNull}
annotation, the checker is able to issue compile-time warnings about
possible run-time exceptions, which is its purpose.  Marking the parameter
as \code{@Nullable} would suppress such warnings, which is undesirable.

% (The note at
% http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/base/Preconditions.html
% argues that the parameter could be marked as @Nullable, since it is
% possible for null to flow there at run time.  However, since that is an
% erroneous case, the annotation would be counterproductive rather than
% useful.)


\subsubsection{Subclasses must respect superclass annotations\label{annotations-are-a-contract}}

An annotation indicates a guarantee that a client can depend upon.  A subclass
is not permitted to \emph{weaken} the contract; for example,
if a method accepts \code{null} as an argument, then every overriding
definition must also accept \code{null}.
A subclass is permitted to \emph{strengthen} the contract; for example,
if a method does \emph{not} accept \code{null} as an argument, then an 
overriding definition is permitted to accept \code{null}.

As a bad example, consider an erroneous \code{@Nullable} annotation at
line 141 of \ahref{http://code.google.com/p/google-collections/source/browse/trunk/src/com/google/common/collect/Multiset.java}{\code{com/google/common/collect/Multiset.java}}, version r78:

\begin{Verbatim}
101  public interface Multiset<E> extends Collection<E> {
...
122    /**
123     * Adds a number of occurrences of an element to this multiset.
...
129     * @param element the element to add occurrences of; may be {@code null} only
130     *     if explicitly allowed by the implementation
...
137     * @throws NullPointerException if {@code element} is null and this
138     *     implementation does not permit null elements. Note that if {@code
139     *     occurrences} is zero, the implementation may opt to return normally.
140     */
141    int add(@Nullable E element, int occurrences);
\end{Verbatim}

There exist implementations of Multiset that permit \code{null} elements,
and implementations of Multiset that do not permit \code{null} elements.  A
client with a variable \code{Multiset ms} does not know which variety of
Multiset \code{ms} refers to.  However, the \code{@Nullable} annotation
promises that \code{ms.add(null, 1)} is permissible.  (Recall from
Section~\ref{annotate-normal-behavior} that annotations should indicate
normal behavior.)

If parameter \code{element} on line 141 were to be annotated, the correct
annotation would be \code{@NonNull}.  Suppose a client has a reference to
same Multiset \code{ms}.  The only way the clienc can be sure not to throw an exception is to pass
only non-\code{null} elements to \code{ms.add()}.  A particular class
that implements Multiset could declare \code{add} to take a
\code{@Nullable} parameter.  That still satisfies the original contract.
It strengthens the contract by promising even more:  a client with such a
reference can pass any non-\code{null} value to \code{add()}, and may also
pass \code{null}.

\textbf{However}, the best annotation for line 141 is no annotation at all.
The reason is that each implementation of the Multiset interface should
specify its own nullness properties when it specifies the type parameter
for Multiset.  For example, two clients could be written as

\begin{Verbatim}
  class MyNullPermittingMultiset implements Multiset<@Nullable Object> { ... }
  class MyNullProhibitingMultiset implements Multiset<@NonNull Object> { ... }
\end{Verbatim}

\noindent
or, more generally, as

\begin{Verbatim}
  class MyNullPermittingMultiset<E extends @Nullable Object> implements Multiset<E> { ... }
  class MyNullProhibitingMultiset<E extends @NonNull Object> implements Multiset<E> { ... }
\end{Verbatim}

Then, the specification is more informative, and the Checker Framework is
able to do more precise checking, than if line 141 has an annotation.

It is a pleasant feature of the Checker Framework that in many cases, no
annotations at all are needed on type parameters such as \code{E} in MultiSet.


\subsubsection{When to use (and not use) type qualifiers\label{when-to-use-type-qualifiers}}

For some programming tasks, you can use either a Java subclass or a type
qualifier.  For instance, suppose that your code currently uses
\code{String} to represent an address.  You could create a new \code{Address}
class and refactor your code to use it, or you could create a
\code{@Address} annotation and apply it to some uses of \code{String} in
your code.  If both of these are truly possible, then it is probably more
foolproof to use the Java class.  We do not encourage you to use type
qualifiers as a poor substitute for classes.  However, sometimes type
qualifiers are a better choice.

Using a new class may your code incompatible with existing libraries or
clients.  Brian Goetz expands on this issues in an article on the
pseudo-typedef antipattern~\cite{Goetz2006:typedef}.  Even if compatibility
is not a concern, a code change may introduce bugs, whereas adding
annotations does not change the run-time behavior.  It is possible to add
annotations to existing code, including code you do not maintain or cannot
change.  It is possible to annotate primitive types without converting them
to wrappers, which would make the code both uglier and slower.

Type qualifiers can be applied to any type, including final classes that
cannot be subclassed.

Type qualifiers permit you to remove operations, with a compile-time
guarantee.  An example is mutating methods that are forbidden by immutable
types (see Sections~\ref{igj-checker} and~\ref{igj-checker}).  More
generally, type qualifiers permit creating a new supertype, not just a
subtype, of an existing Java type.

% This is the least important reason.
A final reason is efficiency.  Type qualifiers can be more
efficient, since there is no no run-time representation such as a wrapper
or a separate class, nor introduction of dynamic dispatch for methods that
could otherwise be statically dispatched.


\subsubsection{Annotations on constructor invocations\label{annotations-on-constructor-invocations}}

%% I want to get rid of this syntax.

In the checkers distributed with the Checker Framework, an annotation on a
constructor invocation is equivalent to a cast on a constructor result.
That is, the following two expressions have identical semantics:  one is
just shorthand for the other.

\begin{Verbatim}
  new @ReadOnly Date()
  (@ReadOnly Date) new Date()
\end{Verbatim}

However, you should rarely have to use this.  The Checker Framework will
determine the qualifier on the result, based on the ``return value''
annotation on the constructor definition.  The ``return value'' annotation
appears before the constructor name, for example:

\begin{Verbatim}
  class MyClass {
    @ReadOnly MyClass() { ... }
  }
\end{Verbatim}

In general, you should only use this syntax when you know that the cast is
guaranteed to succeed.  An example from the IGJ checker
(section~\ref{igj-checker}) is \<new @Immutable MyClass()> or \<new
@Mutable MyClass()>, where you know that every other reference to the class
is annotated \<@Readonly>.





% LocalWords:  NonNull zipfile processor classfiles annotationname javac htoc
% LocalWords:  SuppressWarnings un skipClasses java plugins plugin TODO cp igj
% LocalWords:  nonnull javari langtools sourcepath classpath OpenJDK pre jsr
% LocalWords:  Djsr quals Alint javac's dotequals nullable supertype JLS Papi
% LocalWords:  deserialization Mahmood Telmo Correa changelog txt nullness ESC
% LocalWords:  Nullness Xspacesincomments unselect checkbox unsetting PolyNull
% LocalWords:  bashrc IDE xml buildfile PolymorphicQualifier enum API elts INF
% LocalWords:  typechecker proc discoverable Xlint util QualifierDefaults Foo
% LocalWords:  DefaultQualifier DefaultQualifiers SoyLatte GetStarted Formatter
% LocalWords:  Dcheckers Warski MyClass ProcessorName compareTo toString myDate
% LocalWords:  ReadOnly readonlyObject int XDTA spacesincomments newdir Awarns
% LocalWords:  subpackages bak tIDE Multiset NullPointerException AskipClasses
% LocalWords:  html
