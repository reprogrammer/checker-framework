\htmlhr
\chapter{Introduction\label{introduction}}

The Checker Framework enhances Java's type system to make it more powerful
and useful.
This lets software developers detect and
prevent errors in their Java programs.

The Checker Framework comes with checkers for specific types of errors:

\begin{enumerate}

\item
  \ahrefloc{nullness-checker}{Nullness checker} for null pointer errors
  (see \chapterpageref{nullness-checker})
\item
  \ahrefloc{interning-checker}{Interning checker} for errors in equality
  testing and interning (see \chapterpageref{interning-checker})
\item
  \ahrefloc{lock-checker}{Lock checker} for concurrency and lock errors,
  inspired by the Java Concurrency in Practice (JCIP) annotations (see
  \chapterpageref{lock-checker})
\item
  \ahrefloc{fenum-checker}{Fake enum checker} to allow type-safe fake enum
  patterns (see \chapterpageref{fenum-checker})
\item
  \ahrefloc{tainting-checker}{Tainting checker} for trust and security errors
  (see \chapterpageref{tainting-checker})
\item
  \ahrefloc{regex-checker}{Regex checker} to prevent use of syntactically
  invalid regular expressions (see \chapterpageref{regex-checker})
\item
  \ahrefloc{propkey-checker}{Property file checker} to ensure that valid
  keys are used for property files and resource bundles (see
  \chapterpageref{propkey-checker}).
  Also includes a checker that code is properly internationalized.
  %% Not interesting enough to go at the beginning of the introduction.
  % and a checker for compiler message keys as used in the Checker Framework.
\item
  \ahrefloc{signature-checker}{Signature string checker} to ensure that the
  string representation of a type is properly used, for example in
  \<Class.forName> (see \chapterpageref{signature-checker}).
  Also includes a checker that code is properly internationalized.
  %% Not interesting enough to go at the beginning of the introduction.
  % and a checker for compiler message keys as used in the Checker Framework.
\item
  \ahrefloc{units-checker}{Units checker} to ensure operations are
  performed on correct units of measurement
  (see \chapterpageref{units-checker})
\item
  \ahrefloc{linear-checker}{Linear checker} to control aliasing and prevent
  re-use (see \chapterpageref{linear-checker})
\item
  \ahrefloc{igj-checker}{IGJ checker} for mutation errors (incorrect
  side effects), based on the IGJ type system (see
  \chapterpageref{igj-checker})
\item
  \ahrefloc{javari-checker}{Javari checker} for mutation errors
  (incorrect side effects), based on the Javari type system (see
  \chapterpageref{javari-checker})
\item
  \ahrefloc{basic-checker}{Basic checker} for customized checking without
  writing any code (see \chapterpageref{basic-checker})
\item
  \ahrefloc{typestate-checker}{Typestate checker} to ensure operations are
  performed on objects that are in the right state, such as only opened
  files being read (see \chapterpageref{typestate-checker})
\item
  \ahrefloc{third-party-checkers}{Third-party checkers} that are distributed
  separately from the Checker Framework
  (see \chapterpageref{third-party-checkers})

% Keep this list in sync with the list in manual.tex.
\end{enumerate}

\noindent
These checkers are easy to use and are invoked as arguments to \<javac>.


The Checker Framework also enables you to write new checkers of your
own; see Chapters~\ref{basic-checker} and~\ref{writing-a-checker}.


\section{How it works:  Pluggable types\label{pluggable-types}}

The Checker Framework supports adding
pluggable type systems to the Java language in a backward-compatible way.
Java's built-in typechecker finds and prevents many errors --- but it
doesn't find and prevent \emph{enough} errors.  The Checker Framework lets you
run an additional typechecker as a plug-in to the javac compiler.  Your
code stays completely backward-compatible:  your code compiles with any
Java compiler, it runs on any JVM, and your coworkers don't have to use the
enhanced type system if they don't want to.  You can check only part of
your program.  Type inference tools exist to help you annotate your
code.


A type system designer uses the Checker Framework to define type qualifiers
and their semantics, and a
compiler plug-in (a ``checker'') enforces the semantics.  Programmers can
write the type qualifiers in their programs and use the plug-in to detect
or prevent errors.  The Checker Framework is useful both to programmers who
wish to write error-free code, and to type system designers who wish to
evaluate and deploy their type systems.



% This manual is organized as follows.
% \begin{itemize}
% \item Chapter~\ref{introduction} overviews the Checker Framework and
%   describes how to \ahrefloc{installation}{install} it (Chapter~\ref{installation}).
% \item Chapter~\ref{using-a-checker} describes how to \ahrefloc{using-a-checker}{use a checker}.
% \item
%   The next chapters are user manuals for the \ahrefloc{nullness-checker}{Nullness}
%   (Chapter~\ref{nullness-checker}), \ahrefloc{interning-checker}{Interning}
%   (Chapter~\ref{interning-checker}), \ahrefloc{javari-checker}{Javari} (Chapter~\ref{javari-checker}),
%   \ahrefloc{igj-checker}{IGJ} (Chapter~\ref{igj-checker}), and \ahrefloc{basic-checker}{Basic}
%   (Chapter~\ref{basic-checker}) checkers.
% \item Chapter~\ref{annotating-libraries} describes an approach for \ahrefloc{annotating-libraries}{annotating external
% libraries}.
% \item Chapter~\ref{writing-a-checker} describes how to
%   \ahrefloc{writing-a-checker}{write a new checker} using the Checker Framework.
% \end{itemize}






This document uses the terms ``checker'', ``checker plugin'',
``type-checking compiler plugin'', and ``annotation processor'' as
synonyms.

\section{Installation\label{installation}}

This section describes how to install the binary release of the Checker
Framework.  The binary release contains everything that you need, both to
run checkers and to write your own checkers.  As an alternative, you can
build the latest development version from source
(Section~\refwithpage{build-source}).

% Not "\ahrefurl" because it looks bad in the printed manual.
\textbf{Requirement:}
You must have \textbf{JDK 6} or later installed.  You can get JDK 6 from
\ahref{http://www.oracle.com/technetwork/java/javase/downloads/index.html}{Oracle}
or elsewhere.  If you are using Apple Mac OS X, you can use
\ahref{http://developer.apple.com/search/index.php?q=java}{Apple's implementation},
\ahref{http://landonf.bikemonkey.org/static/soylatte/}{SoyLatte},
or the \ahref{http://openjdk.java.net/}{OpenJDK}.

The installation process is simple!
\begin{enumerate}
\item
  Download the Checker Framework distribution
  (\ahrefurl{http://types.cs.washington.edu/checker-framework/current/checkers.zip}).
\item 
  Unzip it to create a \code{checker-framework} directory.

%% Not needed any more.
%   Then, set the
%   \code{CHECKERS} environment variable to the
%   \code{checker-framework/checkers} directory.  For instance, if you use
%   the bash shell, then add this to your \code{.bashrc} file (don't forget
%   to replace the ``\code{...}''!):
% \begin{Verbatim}
%   export CHECKERS=.../checker-framework/checkers
% \end{Verbatim}
%   Also execute it on the command line, or log out and back in.

\item
  Optionally, update your execution path or create an alias.

  When doing pluggable type-checking, you need to use the ``Type Annotations compiler'', an updated version of the
  OpenJDK javac compiler that
  understands type annotations.    The Type Annotations compiler is
  backward-compatible, so using it as your Java compiler should have no negative consequences.

  You can do this in three ways.  You can use any one of them.  However, if
  you are using the Windows command shell, you must use the last one.  The
  instructions assume a \code{CHECKERS} environment variable that is set
  to the \code{.../checker-framework/checkers} directory, but you can
  use an absolute path if you prefer.

  % Is the last one required for Cygwin, as well as for the Windows command shell?

  \begin{itemize}
  \item
    Add directory
    \code{\$CHECKERS/binary} to your path, \emph{before} any other
    directory that contains a \<javac> executable.  Now, whenever
    you run \code{javac}, you will use the updated compiler.  If you are
    using the bash shell, a way to do this is to add the following to your
    \verb|~/.bashrc| file:
\begin{Verbatim}
  export PATH=${CHECKERS}/binary:${PATH}
\end{Verbatim}
  \item
    Whenever this document tells you to run \code{javac}, you
    can instead run \code{\$CHECKERS/binary/javac}.

    You can simplify this by introducing an alias.  Then,
    whenever this document tells you to run \code{javac}, instead use that
    alias.  Here is the syntax for your 
    \verb|~/.bashrc| file:
\begin{Verbatim}
  alias javacheck='$CHECKERS/binary/javac'
\end{Verbatim}
% Unconfuse Emacs LaTeX mode:  $

 \item
   Whenever this document tells you to run \code{javac}, instead
   run \<java> (not \<javac>),
   but pass an extra \code{-Xbootclasspath/p:} and
   \code{-jar} argument, as in:

\begin{Verbatim}
  java -Xbootclasspath/p:$CHECKERS/binary/jsr308-all.jar -jar $CHECKERS/binary/jsr308-all.jar ...
\end{Verbatim}

    You can simplify this by introducing an alias.  Then,
    whenever this document tells you to run \code{javac}, instead use that
    alias.  For example:

\begin{Verbatim}
  # Unix
  alias javacheck='java -Xbootclasspath/p:$CHECKERS/binary/jsr308-all.jar -jar $CHECKERS/binary/jsr308-all.jar'

  # Windows
  doskey javacheck=java -Xbootclasspath/p:%CHECKERS%\binary\jsr308-all.jar -jar %CHECKERS%\binary\jsr308-all.jar $*
\end{Verbatim}
\end{itemize}

\end{enumerate}


To ensure that it was installed properly, run \<javac -version> (possibly using the
full pathname to \<javac> or the alias, if you did not add the Type Annotations \<javac> to your path).

The output should be:

\begin{Verbatim}
  javac 1.7.0-jsr308-1.4.2
\end{Verbatim}

That's all there is to it!  Now you are ready to start using the checkers.

Section~\ref{example-use} walks you through a simple example.  More detailed
instructions for using a checker appear in Chapter~\ref{using-a-checker}.


\section{Example use:  detecting a null pointer bug\label{example-use}}

To run a checker on a source file, just run javac as usual, passing the
\<-processor> flag.  (You can also use an IDE or other build tool; see
Chapter~\ref{external-tools}.)

For instance, if you usually run the compiler like
this:

\begin{Verbatim}
  javac Foo.java Bar.java
\end{Verbatim}

\noindent
then you will instead use the command line:

\begin{alltt}
  javac -processor \textit{ProcessorName} Foo.java Bar.java
\end{alltt}

\noindent
but take note that the \code{javac} command must refer to the Type
Annotations compiler (see Section~\ref{installation}).


If you usually do your coding within an IDE, you will need to configure
the IDE.  This manual contains instructions for
Ant (Section~\ref{ant-task}),
Maven (Section~\ref{maven-plugin}),
IntelliJ IDEA (Section~\ref{intellij}),
Eclipse (Section~\ref{eclipse}), and
tIDE (Section~\ref{tide}).
Otherwise, see your IDE documentation for details.


\begin{enumerate}
\item
  Let's consider this very simple Java class.  One local variable is
  annotated as \<NonNull>, indicating that \<ref> must be a reference to a
  non-null object.  Save the file as \<GetStarted.java>.

\begin{Verbatim}
import checkers.nullness.quals.*;

public class GetStarted {
    void sample() {
        @NonNull Object ref = new Object();
    }
}
\end{Verbatim}

\item
  Run the nullness checker on the class.
  Either run this command:
\begin{Verbatim}
  javac -processor checkers.nullness.NullnessChecker GetStarted.java
\end{Verbatim}

\noindent
or compile from within your IDE, which you have customized to use the JSR
308 compiler and to pass the extra arguments.

  The compilation should complete without any errors.

\item
  Let's introduce an error now.  Modify \<ref>'s assignment to:
\begin{Verbatim}
  @NonNull Object ref = null;
\end{Verbatim}

\item
  Run the nullness checker again, just as before.  This run should emit
  the following error:
\begin{Verbatim}
GetStarted.java:5: incompatible types.
found   : @Nullable <nulltype>
required: @NonNull Object
        @NonNull Object ref = null;
                              ^
1 error
\end{Verbatim}

\end{enumerate}

The type qualifiers (e.g., \<@NonNull>) are permitted anywhere
that would write a type, including generics and casts; see
Section~\ref{writing-annotations}.

\begin{alltt}
  \underline{@Interned} String intern() \ttlcb{} ... \ttrcb{}             // return value
  int compareTo(\underline{@NonNull} String other) \ttlcb{} ... \ttrcb{}  // parameter
  \underline{@NonNull} List<\underline{@Interned} String> messages;     // non-null list of interned Strings
\end{alltt}


\htmlhr
\chapter{Using a checker\label{using-a-checker}}

A pluggable type-checker enables you to detect certain bugs in your code,
or to prove that they are not present.  The verification happens at compile
time.


Finding bugs, or verifying their absence, with a checker plugin is a two-step process, whose steps are
described in Sections~\ref{writing-annotations} and \ref{running}.

\begin{enumerate}

\item The programmer writes annotations, such as \code{@\refclass{nullness/quals}{NonNull}} and
  \code{@\refclass{interning/quals}{Interned}}, that specify additional information about Java types.
  (Or, the programmer uses an inference tool to automatically insert
  annotations in his code:  see Sections~\ref{nullness-inference} and~\ref{javari-inference}.)
  It is possible to annotate only part of your code:  see
  Section~\ref{unannotated-code}.

\item The checker reports whether the program contains any erroneous code
  --- that is, code that is inconsistent with the annotations.

\end{enumerate}

This chapter is structured as follows:
\begin{itemize}
\item Section~\ref{writing-annotations}: How to write annotations
\item Section~\ref{running}:  How to run a checker
\item Section~\ref{checker-guarantees}: What the checker guarantees
\item Section~\ref{tips-about-writing-annotations}: Tips about writing annotations
\end{itemize}

Additional topics that apply to all checkers are covered later in the manual:
\begin{itemize}
\item Chapter~\ref{advanced-type-system-features}: Advanced type system features
\item Chapter~\ref{warnings-and-legacy}: Handling warnings and legacy code
\item Chapter~\ref{annotating-libraries}: Annotating libraries
\item Chapter~\ref{writing-a-checker}: How to create a new checker
\item Chapter~\ref{external-tools}: Integration with external tools
\end{itemize}


% The annotations have to be on your classpath even when you are not using
% the -processor, because of the existence of the import statement for
% the annotations.


\section{Writing annotations\label{writing-annotations}}

The syntax of type annotations in Java is specified by
\ahref{http://types.cs.washington.edu/jsr308/}{JSR 308}~\cite{JSR308-2008-09-12}.  Ordinary
Java permits annotations on declarations.  JSR 308 permits annotations
anywhere that you would write a type, including generics and casts.  You
can also write annotations to indicate type qualifiers for array levels and
receivers.  Here are a few examples:

\begin{alltt}
  \underline{@Interned} String intern() \ttlcb{} ... \ttrcb{}               // return value
  int compareTo(\underline{@NonNull} String other) \ttlcb{} ... \ttrcb{}    // parameter
  String toString(\underline{@ReadOnly} MyClass this) \ttlcb{} ... \ttrcb{} // receiver ("this" parameter)
  \underline{@NonNull} List<\underline{@Interned} String> messages;       // generics:  non-null list of interned Strings
  \underline{@Interned} String \underline{@NonNull} [] messages;          // arrays:  non-null array of interned Strings
  myDate = (\underline{@ReadOnly} Date) readonlyObject;       // cast
\end{alltt}

You can also write the annotations within comments, as in
\code{List</*@NonNull*/ String>}.  The Type Annotations compiler, which is
distributed with the Checker Framework, will still process
the annotations.
However, your code will remain compilable by people who are not using the
Type Annotations compiler.  For more details, see
Section~\ref{annotations-in-comments}.



\subsection{Distributing your annotated project\label{distributing}}

If your code contains annotations, then your code has a dependency on the
annotation declarations.  People who want to compile or run your code may
need declarations of the annotations on their classpath.

\begin{itemize}
\item
To perform pluggable type-checking, all of the Checker Framework (which
also contains the annotation declarations) is needed.
\item
To compile the code:
\begin{itemize}
\item
  If you wrote annotations in comments (see
  Section~\ref{annotations-in-comments}) and/or used implicit import
  statements (see Section~\ref{implicit-import-statements}), then the code
  can be compiled by any Java compiler, without needing declarations of the
  annotations.
\item
  Otherwise, compiling the code requires a declaration of the annotations.
  These appear in the full Checker Framework.  Additionally, the Checker
  Framework distribution \code{.zip} file contains a small jar file,
  \code{checkers-quals.jar}, that only contains the definitions of the
  distributed qualifiers, without any support for type-checking.
\end{itemize}
\item
To run the code:
\begin{itemize}
\item
  If you compiled the code without using the annotation declarations, then
  no annotation declarations are needed.
\item
  If you compiled the code using the annotation declarations, then users
  may need to have the annotation declarations on their classpath.
\end{itemize}
\end{itemize}

A simple rule of thumb is as follows.  When distributing your source code,
you may wish to include either the Checker Framework jar file or the
\code{checkers-quals.jar} file.  When distributing compiled binaries, you
may wish to compile them without using the annotations, or include the
contents of \code{checkers-quals.jar} in your distribution.


\section{Running a checker\label{running}}

To run a checker plugin, run the compiler \code{javac} as usual,
but pass the \code{-processor \emph{plugin\_class}} command-line
option.
(You can run a checker from within your favorite IDE or build system.  See
Chapter~\ref{external-tools} for details about
Ant (Section~\ref{ant-task}),
Maven (Section~\ref{maven-plugin}),
IntelliJ IDEA (Section~\ref{intellij}),
Eclipse (Section~\ref{eclipse}),
and
tIDE (Section~\ref{tide}), and about customizing other IDEs and build tools.)
Remember that you must be using the
Type Annotations version of \<javac>, which you already installed (see Section~\ref{installation}).

Two concrete examples (using the Nullness checker) are:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  javac -processor checkers.nullness.NullnessChecker MyFile.java
  javac -processor checkers.nullness.NullnessChecker -Xbootclasspath/p:checkers/jdk/jdk.jar MyFile.java
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\noindent
For a discussion of the \code{-Xbootclasspath/p} argument, see
Section~\ref{skeleton-using}.

The checker is run only on any Java file that javac compiles.
This includes all Java files specified on the command line (or
created by another annotation processor).  It may also include other of
your Java files (but not if a more recent \code{.class} file exists).
Even when the checker does not analyze a class (say, the class was
already compiled, or source code is not available), it does check
the \emph{uses} of those classes in the source code being compiled.

You can always compile the code without the \code{-processor}
command-line option, but in that case no checking of the type
annotations is performed.  The annotations are still written to the
resulting \<.class> files, however.



\subsection{Summary of command-line options\label{checker-options}}

You can pass command-line arguments to a checker via javac's standard \<-A>
option (``\<A>'' stands for ``annotation'').  All of the distributed
checkers support the following command-line options:

\begin{itemize}
\item \<-AskipUses> Suppress all errors and warnings at all uses of a
  given class; see Section~\ref{suppressing-warnings}
\item \<-AskipDefs> Suppress all errors and warnings within the definition of a
  given class; see Section~\ref{suppressing-warnings}
\item \<-Astubs> List of stub files or directories; see Section~\ref{stub-using}
\item \<-Alint> Enable or disable optional checks; see Section~\ref{lint-options}
\item \<-Awarns> Treat checker errors as warnings.  If you use this, you
  may wish to also supply \code{-Xmaxwarns 10000}, because by default
  \<javac> prints at most 100 warnings.
\item \<-Afilenames>, \<-Anomsgtext>, \<-Ashowchecks>, \<-AprintErrorStack>, \<-AprintAllQualifiers>, \<-Aignorejdkastub> Aids for testing or debugging a checker; see Section~\ref{debugging-options}
\end{itemize}

\noindent
Some checkers support additional options, such as \<-Aquals> for the Basic
Checker to check; see Chapter~\ref{basic-checker}.


Here are some standard javac command-line options that you may find useful.
Many of them contain the word ``processor'', because in javac jargon, a
checker is a type of ``annotation processor''.

\begin{itemize}
\item \<-processor> Names the checker to be
  run; see Section~\ref{running}
\item \<-processorpath> Indicates where to search for the
  checker; should also contain any qualifiers used by the Basic
  Checker; see Section~\ref{basic-example}
\item \<-proc:>\{\<none>,\<only>\} Controls whether checking
  happens; \<-proc:none>
  means to skip checking; \<-proc:only> means to do only
  checking, without any subsequent compilation; see
  Section~\ref{checker-auto-discovery}
\item \<-Xbootclasspath/p:> Indicates where to find the annotated JDK classes;
  see Section~\ref{skeleton-using}
\item \<-implicit:class> Suppresses warnings about implicitly compiled files
  (not named on the command line); see Section~\ref{ant-task}
\item \<-XDTA:spacesincomments> parse annotation comments even when they
  contain spaces; applicable only to the Type Annotations compiler; see Section~\ref{annotations-in-comments}
\item \<-J> Supply an argument to the JVM that is running javac; example:
  \<-J-Djsr308\_imports=checkers.nullness.quals.*>; see Section~\ref{implicit-import-statements}
\end{itemize}


\subsection{Checker auto-discovery\label{checker-auto-discovery}}

``Auto-discovery'' makes the \code{javac} compiler always run a checker
plugin, even if you do not explicitly pass the \code{-processor}
command-line option.  This can make your command line shorter, and ensures
that your code is checked even if you forget the command-line option.

To enable auto-discovery, place a configuration file named
\code{META-INF/services/javax.annotation.processing.Processor}
in your classpath.  The file contains the names of the checker plugins to
be used, listed one per line.  For instance, to run the Nullness and the
Interning checkers automatically, the configuration file should contain:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  checkers.nullness.NullnessChecker
  checkers.interning.InterningChecker
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

You can disable this auto-discovery mechanism by passing the
\code{-proc:none} command-line option to \<javac>, which disables all
annotation processing including all pluggable type-checking.

%% Auto-discovering all the distributed checkers by default would be
%% problematic.  So, leave it up to the user to enable auto-discovery.
%%  1. We don't want to auto-discover both the Javari & IGJ type checkers,
%%     as then the user would see multiple, possibly contradictory, types
%%     of mutability diagnostics.
%%  2. The nullness and mutability checkers would issue lots of errors for
%%     unannotated code, and that would be irritating.



\section{What the checker guarantees\label{checker-guarantees}}

A checker can guarantee that a particular property holds throughout the
code.  For example, the Nullness checker (Chapter~\ref{nullness-checker})
guarantees that every expression whose type is a \code{@\refclass{nullness/quals}{NonNull}} type never
evaluates to null.  The Interning checker (Chapter~\ref{interning-checker})
guarantees that every expression whose type is an \code{@\refclass{interning/quals}{Interned}} type
evaluates to an interned value.  The checker makes its guarantee by
examining every part of your program and verifying that no part of the
program violates the guarantee.

There are some limitations to the guarantee.

\urldef{\jlsintersectiontypesurl}{\url}{http://docs.oracle.com/javase/specs/jls/se7/html/jls-4.html#jls-4.9}

\begin{itemize}

\item
  A compiler plugin can check only those parts of your program that you run
  it on.  If you compile some parts of your program without running the
  checker, then there is no guarantee that the entire program satisfies the
  property being checked.  Some examples of un-checked code are:

  \begin{itemize}
  \item
    Code compiled without the \code{-processor} switch, including any
    external library supplied as a \code{.class} file.
  \item
    Code compiled with the \code{-AskipUses} or \code{-AskipDefs}
    properties (see Section~\ref{suppressing-warnings}).
  \item
    Suppression of warnings, such as via the \code{@SuppressWarnings}
    annotation (see Section~\ref{suppressing-warnings}).
  \item
    Native methods (because the implementation is not Java code, it cannot
    be checked).
  \end{itemize}

  In each of these cases, any \emph{use} of the code is checked --- for
  example, a call to a native method must be compatible with any
  annotations on the native method's signature.
  However, the annotations on the un-checked code are trusted; there is no
  verification that the implementation of the native method satisfies the
  annotations.

\item
  Reflection can violate the Java type system, and
  the checkers are not sophisticated enough to reason about the possible
  effects of reflection.  Similarly, deserialization and cloning can
  create objects that could not result from normal constructor calls, and
  that therefore may violate the property being checked.

\item
  The Checker Framework does not yet support annotations on intersection
  types (see
  \ahref{\jlsintersectiontypesurl}{JLS \S4.9}).  As a result, checkers cannot provide guarantees about
  intersection types.

\item
  Specific checkers may have other limitations; see their documentation for
  details.

\end{itemize}

A checker can be useful in finding bugs or in verifying part of a
program, even if the checker is unable to verify the correctness of an
entire program.

In order to avoid a flood of unhelpful warnings, many of the checkers avoid
issuing the same warning multiple times.  For example, in this code:

\begin{Verbatim}
  @Nullable Object x = ...;
  x.toString();                 // warning
  x.toString();                 // no warning
\end{Verbatim}

\noindent
In this case, the second call to \<toString> cannot possibly throw a null
pointer warning --- \<x> is non-null if control flows to the second
statement.
In other cases, a checker avoids issuing later warnings with the same cause
even when later code in a method might also fail.
This does not
affect the soundness guarantee, but a user may need to examine more
warnings after fixing the first ones identified.  (More often, at least in
our experience to date, a single fix corrects all the warnings.)

% It might be worthwhile to permit a user to see every warning -- though I
% would not advocate this setting for daily use.

If you find that a checker fails to issue a warning that it
should, then please report a bug (see Section~\ref{reporting-bugs}).


\section{Tips about writing annotations\label{tips-about-writing-annotations}}


\subsection{How to get started annotating legacy code\label{get-started-with-legacy-code}}

Annotating an entire existing program may seem like a daunting task.  But,
if you approach it systematically and do a little bit at a time, you will
find that it is manageable.

You should start with a property that matters to you, to achieve the best
benefits.  It is easiest to add annotations if you know the code or the
code contains documentation; you will find that you spend most of your time
understanding the code, and very little time actually writing annotations
or running the checker.

Don't get discouraged if you see many type-checker warnings at first.
Often, adding just a few missing annotations will eliminate many warnings,
and you'll be surprised how fast the process goes overall.

It is best to annotate one package at a time,
% Upcoming fix that applies different defaults to annotated and unannotated
% code will eliminate this reason.
and to annotate the entire package so that you don't forget any classes
(failing to annotate a class can lead to unexpected results).
Start as close to the leaves of the call tree as possible, such as with
libraries --- that is,
start with methods/classes/packages that have few dependences on other
code or, equivalently, start with code that a lot of your other code
depends on.  The reason for this is that it is
easiest to annotate a class if the code it calls has already been
annotated.

For each class, read its Javadoc.  For instance, if you are adding
annotations for the Nullness Checker (Section~\ref{nullness-checker}), then
you can search the documentation for ``null'' and then add \<@Nullable>
anywhere appropriate.  Do not annotate the method bodies yet ---
first, get the signatures and fields annotated.  The only reason to even
\emph{read} the method bodies yet is to determine signature annotations for
undocumented methods ---
for example, if the method returns null, you know its return type should be
annotated \<@Nullable>, and a parameter that is compared against \<null>
may need to be annotated \<@Nullable>.  If you are only annotating
signatures (say, for a library you do not maintain and do not wish to
check), you are now done.

If you wish to check the implementation, then after the signatures are
annotated, run the checker.  Then, add method body annotations (usually,
few are necessary), fix bugs in code, and add annotations to signatures
where necessary.  If signature annotations are necessary, then you may want
to fix the documentation that did not indicate the property; but this isn't
strictly necessary, since the annotations that you wrote provide that
documentation.

You may wonder about the effect of adding a given annotation --- how many
other annotations it will require, or whether it conflicts with other code.
Suppose you have added an annotation to a method parameter.  You could
manually examine all callees.  A better way can be to save the checker
output before adding the annotation, and to compare it to the checker
output after adding the annotation.  This helps you to focus on the
specific consequences of your change.

Also see Chapter~\ref{warnings-and-legacy}, which tells you what to do when
you are unable to eliminate checker warnings.



\subsection{Do not annotate local variables unless necessary\label{tips-local-inference}}

The checker infers annotations for local variables (see
Section~\ref{type-refinement}).  Usually, you only need to annotate fields
and method signatures.  After doing those, you can add annotations inside
method bodies if the checker is unable to infer the correct annotation, if
you need to suppress a warning (see Section~\ref{suppressing-warnings}),
etc.


\subsection{Annotations indicate normal behavior\label{annotate-normal-behavior}}

You should use annotations to indicate \emph{normal} behavior.  The
annotations indicate all the values that you \emph{want} to flow to
reference --- not every value that might possibly flow there if your
program has a bug.

Many methods are guaranteed to throw an exception if they are passed \code{null}
as an argument.  Examples include

\begin{Verbatim}
  java.lang.Double.valueOf(String)
  java.lang.String.contains(CharSequence)
  org.junit.Assert.assertNotNull(Object)
  com.google.common.base.Preconditions.checkNotNull(Object)
\end{Verbatim}

\code{@\refclass{nullness/quals}{Nullable}} (see Section~\ref{nullness-annotations})
might seem like a reasonable annotation for the parameter,
for two reasons.  First, \code{null} is a legal argument with a
well-defined semantics:  throw an exception.  Second, \code{@Nullable}
describes a possible program execution:  it might be possible for
\code{null} to flow there, if your program has a bug.

% (Checking for such a bug is the whole purpose of the \code{assertNotNull}
% and \code{checkNotNull} methods.)

However, it is never useful for a programmer to pass \code{null}.  It is
the programmer's intention that \code{null} never flows there.  If
\code{null} does flow there, the program will not continue normally.

Therefore, you should mark such parameters as
\code{@\refclass{nullness/quals}{NonNull}}, indicating
the intended use of the method.  When you use the \code{@NonNull}
annotation, the checker is able to issue compile-time warnings about
possible run-time exceptions, which is its purpose.  Marking the parameter
as \code{@Nullable} would suppress such warnings, which is undesirable.

% (The note at
% http://google-collections.googlecode.com/svn/trunk/javadoc/com/google/common/base/Preconditions.html
% argues that the parameter could be marked as @Nullable, since it is
% possible for null to flow there at run time.  However, since that is an
% erroneous case, the annotation would be counterproductive rather than
% useful.)


\subsection{Subclasses must respect superclass annotations\label{annotations-are-a-contract}}

An annotation indicates a guarantee that a client can depend upon.  A subclass
is not permitted to \emph{weaken} the contract; for example,
if a method accepts \code{null} as an argument, then every overriding
definition must also accept \code{null}.
A subclass is permitted to \emph{strengthen} the contract; for example,
if a method does \emph{not} accept \code{null} as an argument, then an
overriding definition is permitted to accept \code{null}.

As a bad example, consider an erroneous \code{@Nullable} annotation at
line 141 of \ahref{http://code.google.com/p/google-collections/source/browse/trunk/src/com/google/common/collect/Multiset.java}{\code{com/google/common/collect/Multiset.java}}, version r78:

\begin{Verbatim}
101  public interface Multiset<E> extends Collection<E> {
...
122    /**
123     * Adds a number of occurrences of an element to this multiset.
...
129     * @param element the element to add occurrences of; may be {@code null} only
130     *     if explicitly allowed by the implementation
...
137     * @throws NullPointerException if {@code element} is null and this
138     *     implementation does not permit null elements. Note that if {@code
139     *     occurrences} is zero, the implementation may opt to return normally.
140     */
141    int add(@Nullable E element, int occurrences);
\end{Verbatim}

There exist implementations of Multiset that permit \code{null} elements,
and implementations of Multiset that do not permit \code{null} elements.  A
client with a variable \code{Multiset ms} does not know which variety of
Multiset \code{ms} refers to.  However, the \code{@Nullable} annotation
promises that \code{ms.add(null, 1)} is permissible.  (Recall from
Section~\ref{annotate-normal-behavior} that annotations should indicate
normal behavior.)

If parameter \code{element} on line 141 were to be annotated, the correct
annotation would be \code{@NonNull}.  Suppose a client has a reference to
same Multiset \code{ms}.  The only way the client can be sure not to throw an exception is to pass
only non-\code{null} elements to \code{ms.add()}.  A particular class
that implements Multiset could declare \code{add} to take a
\code{@Nullable} parameter.  That still satisfies the original contract.
It strengthens the contract by promising even more:  a client with such a
reference can pass any non-\code{null} value to \code{add()}, and may also
pass \code{null}.

\textbf{However}, the best annotation for line 141 is no annotation at all.
The reason is that each implementation of the Multiset interface should
specify its own nullness properties when it specifies the type parameter
for Multiset.  For example, two clients could be written as

\begin{Verbatim}
  class MyNullPermittingMultiset implements Multiset<@Nullable Object> { ... }
  class MyNullProhibitingMultiset implements Multiset<@NonNull Object> { ... }
\end{Verbatim}

\noindent
or, more generally, as

\begin{Verbatim}
  class MyNullPermittingMultiset<E extends @Nullable Object> implements Multiset<E> { ... }
  class MyNullProhibitingMultiset<E extends @NonNull Object> implements Multiset<E> { ... }
\end{Verbatim}

Then, the specification is more informative, and the Checker Framework is
able to do more precise checking, than if line 141 has an annotation.

It is a pleasant feature of the Checker Framework that in many cases, no
annotations at all are needed on type parameters such as \code{E} in \<MultiSet>.


\subsection{Annotations on constructor invocations\label{annotations-on-constructor-invocations}}

%% I want to get rid of this syntax.
%% However, @Linear provides a compelling use case.

In the checkers distributed with the Checker Framework, an annotation on a
constructor invocation is equivalent to a cast on a constructor result.
That is, the following two expressions have identical semantics:  one is
just shorthand for the other.

\begin{Verbatim}
  new @ReadOnly Date()
  (@ReadOnly Date) new Date()
\end{Verbatim}

However, you should rarely have to use this.  The Checker Framework will
determine the qualifier on the result, based on the ``return value''
annotation on the constructor definition.  The ``return value'' annotation
appears before the constructor name, for example:

\begin{Verbatim}
  class MyClass {
    @ReadOnly MyClass() { ... }
  }
\end{Verbatim}

In general, you should only use an annotation on a constructor invocation
when you know that the cast is
guaranteed to succeed.  An example from the IGJ checker
(Chapter~\ref{igj-checker}) is \<new @Immutable MyClass()> or \<new
@Mutable MyClass()>, where you know that every other reference to the class
is annotated \<@ReadOnly>.


\subsection{When to use (and not use) type qualifiers\label{when-to-use-type-qualifiers}}

For some programming tasks, you can use either a Java subclass or a type
qualifier.  For instance, suppose that your code currently uses
\code{String} to represent an address.  You could create a new \code{Address}
class and refactor your code to use it, or you could create a
\code{@Address} annotation and apply it to some uses of \code{String} in
your code.  If both of these are truly possible, then it is probably more
foolproof to use the Java class.  We do not encourage you to use type
qualifiers as a poor substitute for classes.  However, sometimes type
qualifiers are a better choice.

Using a new class may make your code incompatible with existing libraries or
clients.  Brian Goetz expands on this issues in an article on the
pseudo-typedef antipattern~\cite{Goetz2006:typedef}.  Even if compatibility
is not a concern, a code change may introduce bugs, whereas adding
annotations does not change the run-time behavior.  It is possible to add
annotations to existing code, including code you do not maintain or cannot
change.  It is possible to annotate primitive types without converting them
to wrappers, which would make the code both uglier and slower.

Type qualifiers can be applied to any type, including final classes that
cannot be subclassed.

Type qualifiers permit you to remove operations, with a compile-time
guarantee.  An example is mutating methods that are forbidden by immutable
types (see Chapters~\ref{igj-checker} and~\ref{javari-checker}).  More
generally, type qualifiers permit creating a new supertype, not just a
subtype, of an existing Java type.

% This is the least important reason.
A final reason is efficiency.  Type qualifiers can be more
efficient, since there is no run-time representation such as a wrapper
or a separate class, nor introduction of dynamic dispatch for methods that
could otherwise be statically dispatched.


\subsection{What to do if a checker issues a warning about your code\label{handling-warnings}}

When you first run a type-checker on your code, it is likely to issue
warnings or errors.  For each warning, try to understand why the checker
issues it.  (For example, if you are using the
\ahrefloc{nullness-checker}{Nullness checker}
(\chapterpageref{nullness-checker}), try to understand why it cannot prove
that no null pointer exception ever occurs.)  The reason will sometimes be
an actually possible null dereference, sometimes be a weakness of the
annotations, and sometimes be a weakness of the checker.  You will need to
examine your code, and possibly write test cases, to understand the reason.

If there is an actual possible null dereference, then fix your code to
prevent that crash.

If there is a weakness in the annotations, then improve the annotations.
For example, continuing the Nullness Checker example, if a particular
variable is annotated as \code{@\refclass{nullness/quals}{Nullable}} but it
actually never contains \<null> at run time, then change the annotation to 
\code{@\refclass{nullness/quals}{NonNull}}.  The weakness might be in the
annotations in your code, or in the annotations in a library that your code
calls.  Another possible problem is that a library is unannotated (see
\chapterpageref{annotating-libraries}).

If there is a weakness in the checker, then your code is safe --- it never
suffers the specific run-time error --- but the checker cannot prove this
fact.  This is most often because the checker is not omniscient, and some
tricky coding paradigms are beyond its analysis capabilities; in this
case, you should suppress the warning (see
\chapterpageref{suppressing-warnings}).  In other cases, the problem is a
bug in the checker; in this case, please report the bug (see
\chapterpageref{reporting-bugs}).


% LocalWords:  NonNull zipfile processor classfiles annotationname javac htoc
% LocalWords:  SuppressWarnings un skipUses java plugins plugin TODO cp igj
% LocalWords:  nonnull javari langtools sourcepath classpath OpenJDK pre jsr
% LocalWords:  Djsr quals Alint javac's dotequals nullable supertype JLS Papi
% LocalWords:  deserialization Mahmood Telmo Correa changelog txt nullness ESC
% LocalWords:  Nullness Xspacesincomments unselect checkbox unsetting PolyNull
% LocalWords:  bashrc IDE xml buildfile PolymorphicQualifier enum API elts INF
% LocalWords:  typechecker proc discoverable Xlint util QualifierDefaults Foo
% LocalWords:  DefaultQualifier DefaultQualifiers SoyLatte GetStarted Formatter
% LocalWords:  Dcheckers Warski MyClass ProcessorName compareTo toString myDate
% LocalWords:  ReadOnly readonlyObject int XDTA spacesincomments newdir Awarns
% LocalWords:  subpackages bak tIDE Multiset NullPointerException AskipUses
% LocalWords:  html JCIP MultiSet Astubs Afilenames Anomsgtext Ashowchecks tex
% LocalWords:  Aquals processorpath regex RegEx Xmaxwarns Xbootclasspath com
% LocalWords:  IntelliJ assertNotNull checkNotNull Goetz antipattern subclassed
% LocalWords:  callees Xmx unconfuse fenum propkey forName
