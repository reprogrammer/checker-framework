
Checker Framework redesign/refactoring:

* eliminate use of reflection in composing a type-checker from
  similarly-named classes; force this to be explicit

* change from AST visiting to CFG visiting, so that each type system doesn't
  have to implement special logic to infer where boxing and unboxing occurs.

* there are currently multiple ways to obtain an error reporter and other
  global values.  Put these in a Checker Framework environment, and make all
  the code use a single consistent way to obtain them.  This will make the
  code easier to understand and will make mocking easier to do.

* staging for compound checkers:  ability to run multiple checkers within a
  single type system

* staging of steps within a checker:  separate conceptually distinct tasks,
  such as implicits/defaults/flow/typevalidity/subtyping/customchecks.
  This can be done in twwo spages:two tasks:
   1.  Using the current AnnotatedTypeFactory's lazy approach to annotation,
       separate the current logic into individual steps, where each step is run
       successively on the current tree.
   2.  Abandon the lazy approach.  Separate the current logic into steps that
       are run over an entire compilation unit.  This is to avoid the visitor 
       feedback loop that makes debugging so difficult.  

* separate definition of a type-checker from performing type-checking using
  that definition, to make "initialization" of a type system easier
* eliminate postInit method

* load javac via a classloader rather than by starting a new process -- this
  may avoid some problems with the Maven and Eclipse plugins?


* use a single Processor implementation and ensure checker writers never have
to worry about the Processor interface.  Invocation could be done a number of
ways:
javac --processor checkers.CheckerFramework -Acheckers:checker1:checker2:checker
javac --checkers checker1:checker2:checkers3 
By the way, the second option will work with both the jsr308 and Java8
compilers as the --checkers could be translated by CheckerMain into the first
form.  


Inference-related tasks:

* Create unique ids for each annotated type location in source code, these IDs
will replace inference's ids.  This can be a discrete task, though I would
imagine there are some interactions with Stuart's code.   

* Add a callback for either generating constraints or enforcing checks in
either commonAssignmentCheck or QualifierHierarchy.  If this is done through
QualifierHierarchy, create methods isSubtype and mustBeSubtype to distinguish
between the the times when isSubtype is used in conditionals rather than to
enforce a subtype relationship

* Add a Solve step to the top-level control flow.  Perhaps, as part of the high
level staging this step can optionally be replaced by a PrintConstraints step,
or a GenerateGame step.

