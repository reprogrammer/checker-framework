
Necessary changes to the manual.  In brackets I (Stefan) wrote the names of people familiar with the particular change, which might be most qualified to make the change.  If no person is listed, than anyone could do the change.

------------------------------------------------------

New section on concepts and annotations that apply to all type-systems and checkers

Where would a good place be for this?  At the beginning/end?  Split into multiple sections?

- Pre-/postconditions from a user perspective:
  - Explain the generic pre- and postcondition annotations: @EnsuresAnnotation/@EnsuresAnnotations, @EnsuresAnnotationIf/@EnsuresAnnotationsIf and @RequiresAnnotation/@RequiresAnnotations.
  - Explain what kind of strings are supported (see text near the end of this documentat; use that to augment the existing Checker Framework documentation).

- Pre-/postconditions from a developer perspective:
  - Explain the meta-annotations @PreconditionAnnotation, @ConditionalPostconditionAnnotation and @PostconditionAnnotation.

- Dataflow analysis
  - Explain the command line parameter -Adotflowdir (probably find a better name first) [Stefan/Charlie].

- Document -ANullnessChecker_option=value mechanism

------------------------------------------------------

The Javadoc for DefaultQualifieers uses ALL_EXCEPT_LOCALS in an example.
Replace it and document how to achieve CLIMB-to-top instead.

------------------------------------------------------

Explain relationship between XXXChecker and XXXAnnotatedTypeFactory:
if the Checker is a subtype of BaseTypeChecker, the ATF has to be a
subtype of AbstractBasicATF, because BaseTypeVisitor assumes that.

We found a better naming scheme than Basic vs. Base; it needs to be documented.

------------------------------------------------------

[Stefan]

Explanations on what flow expressions are supported (i.e. strings in pre/postconditions):

- Flow expressions:  There is fairly good support for methods with arguments now.   In general, the following features work.
    - Field accesses of the form "expr.f" (for any flow expression "expr", including method calls or other field access expressions).
    - Static field accesses of the form "ClassName.f".
    - Pure method calls (with or without parameters) of the form "expr.method(arg1, arg2, ...).  This even works for overloaded methods and methods with type parameters.
    - Static pure method calls.
    - Self reference (i.e., "this").  It can be left off in which case the (static or non-static) field/method is searched for in the current class (just like in normal Java).  That is, both "f" and "this.f" work.
    - Parameters to the method that a contract annotation belongs, #1, #2, etc.
    - String literals, integer literals, long literals, null literal.
- Flow expressions limitations: There are some limitations that I'm aware of, but I don't think any of these are severe.  Let me know if you think we should include any of them.
    - Other literals, e.g. floats, doubles, chars or class literals.
    - String concatenation expressions.
    - Mathematical operators (plus, minus, division, ...).
    - Comparisons (equality, less than, etc.).
    - Probably other Java expressions that are "pure" (non-pure things cannot occur, anyway) that I did not think of.
What about array references, such as this.myArray[i]?
See test case checkers/tests/nullness/EnsuresNonNullIfTest3.java .


We allow non-pure methods in specifications.  This is non-standard.  If
a specification is going to be checked at run time via assertions, then the
specification must not use methods with side effects.  But, our checking is
at compile time, so the semantics are clear and we allow it.

------------------------------------------------------

Eclipse setup
-------------
Describe checker-framework.importorder and formatter.
Should these developer-focused configs be moved somewhere else?

------------------------------------------------------

Changelog

Don't forget to update the changelog if you make changes.

------------------------------------------------------
