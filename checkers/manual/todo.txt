
Necessary changes to the manual.  In brackets I (Stefan) wrote the names of people familiar with the particular change, which might be most qualified to make the change.  If no person is listed, than anyone could do the change.



New section on concepts and annotations that apply to all type-systems and checkers
===========================================================================
What would a good place be for this?  At the beginning/end?  Split into multiple sections?

- Purity annotation
  - Explain the annotation and its semantics (can probably mostly taken from the javadoc of @Pure).
  - Explain the command line parameter -AsuggestPureMethods, as well as what the purity analysis does (again, see javadoc of @Pure).

- Pre-/postconditions from a user perspective:
  - Explain the generic pre- and postcondition annotations: @EnsuresAnnotation/@EnsuresAnnotations, @EnsuresAnnotationIf/@EnsuresAnnotationsIf and @RequiresAnnotation/@RequiresAnnotations.
  - Explain what kind of strings are supported (see at the end of the documentation for a list).

- Pre-/postconditions from a developer perspective:
  - Explain the meta-annotations @PreconditionAnnotation, @ConditionalPostconditionAnnotation and @PostconditionAnnotation.

- Dataflow analysis
  - Explain the new defaulting for local variables (including our decision on casts and instanceof).
  - Explain the command line parameter -Adotflowdir (probably find a better name first) [Stefan/Charlie].
  - Explain the new annotation @TerminatesExecution.
  - Document -AconcurrentSemantics command-line option; also note it in caveats about what the checker guarantees [Stefan].
  - Document -AassumeAssertionsAreEnabled and -AassumeAssertionsAreDisabled [Stefan].

- Document @Covariant annotation [Mike/Werner].


Changes throughout the manual to existing sections
===========================================================================

Document the lint option strictMonotonicNonNullInit for NonNullChecker (disallow null initializations for @MonoNonNull fields)

------------------------------------------------------

[Stefan]

After an expression has been unboxed, it is assumed to be non-null (if it was not, then a NPE has occured).  This prevents many errors for the same problem, just like there is only one error for "o.toString(); o.toString()".

------------------------------------------------------

Update the documentation on how to suppress warnings using assert statements: The string @AssumeAssertion(warningkey) must be present anywhere in the detail message of the assert statement.

------------------------------------------------------

"NNEL" default becomes "top for locals, casts, and instanceof"
The top qualifier should only be added to top-level type variables,
because those will get suitably refined by flow.
For type variables in other positions, e.g. as type argument in your
example, we should not add default qualifiers.

------------------------------------------------------

[Mike]

Discuss that the Checker Framework is stricter than Java, in the sense that
it treats arrays invariantly rather than covariantly.  Explain the rationale

> This is due to Java's covariant array types.  In fact, this problem is not
> unique to the Checker Framework, but you can write a variant of your code
> in standard Java that compiles and type-checks, but does not work at
> run-time:
> 
>   String[] strs = new String[] {""};
>   Object[] tmp = strs;
>   tmp[0] = new Object();
>   String regexp = strs[0];
> 
> This code type-checks, but throws an ArrayStoreException at runtime. For
> the Checker Framework, I think it is reasonable to adapt the same covariant
> semantics, which is why your example type-checks.

As Stefan points out, the standard Java type system has a hole, which Java
patches via run-time checks.  The Checker Framework takes a stricter
position, rejecting any unsafe array operation.  (Or, at least, it is
supposed to!)  There are two reasons for this, one philosophical and one
practical:
 * We would like our type system to be sound, which means that we want a
   guarantee of no errors at run time.  Java's type system does not do
   this:  there is only a guarantee that the JVM won't be corrupted, not
   that your program will run without run-time exceptions.
 * The Checker Framework does not add any run-time checking, and so it
   would be undesirable to mimic a feature that is sound only in the
   presence of run-time checking.

-----
An example issue with un-annotated code, for the Regex Checker:

String[] sa = {"hi"};

We infer that "hi" is a "@Regex String" and therefore the RHS has type
"@Regex String[]". With invariant subtyping, the assignment is now
invalid.
The solution is to change the declared type to:

@Regex String[] sa = ...;

Explain this issue in the manual.

------------------------------------------------------

[Mike]

Concurrency:

Add FAQ about:

> How do different approaches handle concurrency?

The Checker Framework currently ignores it.  In the future, we plan to add
a concurrent mode to our toolset, but we expect this will dramatically
reduce the usefulness of the tool for sequential code.  So, for the moment
we are focused on sequential code.

[Mention the concurrency checker and the effect on flow-sensitivity.]

See email thread:
Reality check: how to protect access to @Nullable fields?

Also add a mention to:
2.3  What the checker guarantees

Note that putting data in a local variable doesn't fix the problem, just
masks it from one particular checker.  This is bad style!

------------------------------------------------------

Explain relationship between XXXChecker and XXXAnnotatedTypeFactory:
if the Checker is a subtype of BaseTypeChecker, the ATF has to be a
subtype of AbstractBasicATF, because BaseTypeVisitor assumes that.

Can we find better naming for Basic vs. Base classes?

------------------------------------------------------

[Stefan]

Explanations on what flow expressions are supported (i.e. strings in pre/postconditions):

- Flow expressions:  There is fairly good support for methods with arguments now.   In general, the following features work.
    - Field accesses of the form "expr.f" (for any flow expression "expr", including method calls or other field access expressions).
    - Static field accesses of the form "ClassName.f".
    - Pure method calls (with or without parameters) of the form "expr.method(arg1, arg2, ...).  This even works for overloaded methods and methods with type parameters.
    - Static pure method calls.
    - Self reference (i.e., "this").  It can be left off in which case the (static or non-static) field/method is searched for in the current class (just like in normal Java).  That is, both "f" and "this.f" work.
    - Parameters to the method that a contract annotation belongs, #1, #2, etc.
    - String literals, integer literals, long literals, null literal.
- Flow expressions limitations: There are some limitations that I'm aware of, but I don't think any of these are severe.  Let me know if you think we should include any of them.
    - Other literals, e.g. floats, doubles, chars or class literals.
    - String concatenation expressions.
    - Mathematical operators (plus, minus, division, ...).
    - Comparisons (equality, less than, etc.).
    - Probably other Java expressions that are "pure" (non-pure things cannot occur, anyway) that I did not think of.
