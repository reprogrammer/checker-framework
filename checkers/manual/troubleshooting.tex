\section{Troubleshooting and getting help\label{troubleshooting}}

\subsection{Common problems and solutions\label{common-problems}}

\begin{itemize}

\item
To verify that you are using the compiler you think you are, you can add
\code{-version} to the command line.  For instance, instead of running
\code{javac -g MyFile.java}, you can run \code{javac \underline{-version} -g
  MyFile.java}.  Then, javac will print out its version number in addition
to doing its normal processing.


\item
If you get the error

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
com.sun.tools.javac.code.Symbol$CompletionFailure: class file for com.sun.source.tree.Tree not found
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX

\noindent
then you are using the source installation and file \code{tools.jar} is not
on your classpath.  See the installation instructions
(Section~\ref{installation}).


\item
If you get an error such as

\begin{Verbatim}
package checkers.nullness.quals does not exist
\end{Verbatim}

  \noindent
  despite no apparent use of \code{import checkers.nullness.quals.*;} in
  the source code, then perhaps
  \code{jsr308\_imports} is set as a Java system property, a shell
  environment variable, or a command-line option (see
  Section~\ref{jsr308_imports}).  You can solve this by unsetting the
  variable/option, or by ensuring that the \code{checkers.jar} file is on
  your classpath.


\item
If a checker seems to be ignoring the annotation on a method, then it is
possible that the checker is reading the method's signature from its
\code{.class} file, but the \code{.class} file was not created by the JSR
308 compiler.  You can check whether the annotations actually appear in the
\code{.class} file by using the \code{javap} tool.

If the annotations do not appear in the \code{.class} file, here are two
ways to solve the problem:
\begin{itemize}
\item
  Re-compile the method's class with the Type Annotations compiler.  This will
  ensure that the type annotations are written to the class file, even if
  no type-checking happens during that execution.
\item
  Pass the method's file explicitly on the command line when type-checking,
  so that the compiler reads its source code instead of its \code{.class}
  file.
\end{itemize}

\item
If the compiler reports that it cannot find a method that appears in the
JDK or another external library, then maybe the stub/skeleton file for that
class is incomplete.  You can edit it to add the missing method.  The
libraries appear, for example, at \code{checkers/jdk/nullness/src/} for the
Nullness checker.

The error might take one of these forms:

\begin{Verbatim}
method sleep in class Thread cannot be applied to given types
cannot find symbol: constructor StringBuffer(StringBuffer)
\end{Verbatim}


\end{itemize}


\subsubsection{Known problems in the framework\label{known-problems}}

\begin{itemize}

\item
  The framework may not parse annotations from skeleton files if the
  skeleton files are older than the classfiles.  Running \code{ant
    touch-jdk} solves this problem, by applying the 
  \code{touch} program to each distributed skeleton file.

% Mahmood will address.  -MDE 3/19/2009
\item The framework is missing a check for type argument subtyping in
  method invocations if the type arguments are inferred.

% Mahmood will address.  -MDE 3/19/2009
\item The checks for enclosed types are not yet fully tested.

\end{itemize}

\subsubsection{Known problems in the Nullness checker}

\begin{itemize}
\item
  The Nullness checker is often able to determine that a call to
  \code{Map.get()} will not return null.  This enables the checker to avoid
  issuing false positive warnings, in circumstances like the following.

\begin{Verbatim}
    @NonNull String value;
    if (myMap.containsKey(key)) {
      value = myMap.get(key);
    }
    for (String keyInMap : myMap.keySet()) {
        value = myMap.get(keyInMap);
    }
\end{Verbatim}

  The Nullness checker can sometimes fail to issue a warning if the map is
  modified or re-assigned between the check of \code{containsKey} and the
  call to \code{get}.

% The solution is to merge flow with the Map.get heuristics.
% And to do forward instead of backward analysis.


\item 
  The Nullness checker issues a warning when a constructor does not
  initialize every non-null field.  However, because the checker does not
  fully implement all of Java's definite assignment rules (e.g., for
  \code{finally} blocks), the checker sometimes issues a false positive
  warning.  The checker's behavior is sound but unnecessarily restrictive.
  If you encounter this problem in practice, please submit a bug report so
  that we can improve the checker.

\end{itemize}



\subsection{How to report problems\label{reporting-bugs}}

If you have a problem with any checker, or with the Checker Framework,
please file a bug at 
\url{http://code.google.com/p/checker-framework/issues/list}.

Alternately (especially if your communication is not a bug report), you can
send mail to checker-framework-dev@googlegroups.com.
We welcome suggestions, annotated libraries, bug fixes, new
features, new checker plugins, and other improvements.

Please ensure that your bug report is clear and that it is complete.
Otherwise, we may be unable to understand it or to reproduce it, either of
which would prevent us from fixing the bug.  Your bug report will be most
helpful if you:

\begin{itemize}
\item
  Add \code{-version -verbose} to the javac options.  This causes the compiler to output
  debugging information, including its version number.
\item
  Indicate exactly what you did.  Don't skip any steps, and don't merely
  describe your actions in words.  Show the exact commands by attaching a
  file or using cut-and-paste from your command shell;
\item
  Include all files that are necessary to reproduce the problem.  This
  includes every file that is used by any of the commands you reported, and
  possibly other files as well.
\item
  Indicate exactly what the result was by attaching a fire or using
  cut-and-paste from your command shell (don't merely describe it in
  words).  Also indicate what you expected the result to be --- remember, a
  bug is a difference between desired and actual outcomes.
\end{itemize}


\subsection{Installing the source release\label{install-source}}

The binary release (Section~\ref{installation}) contains everything that
most users need, both to use the distributed checkers and to write your own
checkers.  This section describes how to install from source.  Doing
so permits you to examine and modify the implementation of the distributed
checkers and of the checker framework.  It may also help you to debug
problems more effectively.

% TODO:  We should perhaps later reduce the number of options to just 1...
You have two options.  You can obtain the source code from its version
control repository, or you can obtain a packaged source release.

To obtain the source code from the version control repository, do

\begin{Verbatim}
mkdir -p ~/jsr308
hg clone https://checker-framework.googlecode.com/hg/ checker-framework
\end{Verbatim}


The rest of this section discusses how to install the packaged source release.


\subsubsection{The short instructions (for Linux only)}

%%% This comment does not seem to be correct any longer.
%% This text is identically reproduced at ../../jsr308-langtools/README-jsr308.html
%% so if you change either one, change the other also!

The following commands install
the JSR 308 \code{javac} compiler and the Checker
Framework, or update an existing installation.
It currently works only on \textbf{Linux}.
For more details, or if anything goes wrong, see the comments in the 
\code{Makefile-jsr308-install} file.

\begin{enumerate}

\item
  Execute the following commands:

\begin{Verbatim}
  cd
  wget -nv -N http://types.cs.washington.edu/checker-framework/current/Makefile-jsr308-install
  make -f Makefile-jsr308-install
\end{Verbatim}

\item
Set some environment variables according to the instructions at the top of file
\code{Makefile-jsr308-install}.

\end{enumerate}


\subsubsection{The longer instructions}

The following instructions give detailed steps for installing the source
release of the Checker Framework.

\begin{enumerate}

\item Download and install the JSR 308 implementation; follow the instructions at
% alternative: \urldef{\JsrInstallingUrl}\url{http://types.cs.washington.edu/checker-framework/current/README-jsr308.html#installing}
{\codesize\url{http://types.cs.washington.edu/checker-framework/current/README-jsr308.html#installing}}.
This creates a \code{jsr308-langtools} directory.

\item Download the Checker Framework distribution zipfile from
\myurl{http://types.cs.washington.edu/checker-framework/current/checkers.zip},
and unzip it to create a \code{checkers} directory.  We recommend that the
\code{checkers} directory and the \code{jsr308-langtools} directory be siblings.
Example commands:

\begin{Verbatim}
  cd $JSR308
  wget http://types.cs.washington.edu/checker-framework/current/checkers.zip
  unzip checkers.zip
\end{Verbatim}

You will also need to adjust the path to \<javac> in any Ant buildfiles,
etc.

\item Optionally edit property \code{compiler.lib} in file
  \code{checkers/build.properties}.  You don't have to do this if the
  \code{checkers} directory and the \code{jsr308-langtools} directory are
  siblings.

\item Add to your classpath:
  \code{\$JSR308/jsr308-langtools/lib/tools.jar} and
  \code{\$JSR308/checkers/checkers.jar}.
  (If you do not do this, you will have to supply the \code{-cp} option
  whenever you run \code{javac} and use a checker plugin.)  Example
  commands:

%BEGIN LATEX
\begin{smaller}
%END LATEX
\begin{Verbatim}
  export JSR308=${HOME}/jsr308
  export CLASSPATH=${CLASSPATH}:$JSR308/jsr308-langtools/lib/tools.jar:$JSR308/checkers/checkers.jar
\end{Verbatim}
%BEGIN LATEX
\end{smaller}
%END LATEX
  %% In Cygwin, are reversed slashes required?

\item Test that everything works:

  \begin{itemize}

  \item Run \code{ant all-tests} in the \code{checkers} directory:
\begin{Verbatim}
cd checkers
ant all-tests
\end{Verbatim}

  \item Run the Nullness checker examples (see
    Section~\ref{nullness-example}).

  \end{itemize}

\end{enumerate}

JSR 308 extends the Java language to permit annotations to appear on types,
as in \code{List<@NonNull String>} (see Section~\ref{writing-annotations}).
This change will be part of the Java 7 language.  We recommend that you
write annotations in comments, as in \code{List</*@NonNull*/ String>} (see
Section~\ref{annotations-in-comments}).  The JSR 308 compiler still reads
such annotations, but this syntax permits you to use a compiler other than
the JSR 308 compiler.  For example, you can compile your code with a Java 5
compiler, and you can use a checker as an external tool in an IDE.


% (A checkers implementation builds on
% standard mechanisms such as JSR 269 annotation processing, but also
% accesses the compiler's AST. In the long run, a checker built using the
% Checker Framework should not be dependent on any compiler specifics.)
% If you do not place the annotations in 
% then you should also disable Eclipse's on-the-fly syntax checking.


\subsubsection{Building from source\label{building}}

Building (compiling) the checkers and framework from source creates the
\code{checkers.jar} file.  A pre-compiled \code{checkers.jar} is included
in the distribution, so building it is optional.  It is mostly useful for
people who are developing compiler plug-ins (type-checkers).  If you only
want to \emph{use} the compiler and existing plug-ins, it is sufficient to
use the pre-compiled version.

\begin{enumerate}
\item
Edit \code{checkers/build.properties} file so that the
\code{compiler.lib} property specifies the location of the JSR 308
\code{javac.jar} library.  (If you also installed the JSR 308 compiler from
source, and you made the \code{checkers} and \code{jsr308-langtools} directories
siblings, then you don't need to edit \code{checkers/build.properties}.)

\item
Run \code{ant} in the \code{checkers} directory:

\begin{Verbatim}
cd checkers
ant
\end{Verbatim}

\end{enumerate}


\subsection{Learning more\label{learning-more}}

The technical paper ``Practical pluggable types for Java''~\cite{PapiACPE2008}
(\myurl{http://www.cs.washington.edu/homes/mernst/pubs/pluggable-checkers-issta2008.pdf})
gives more technical detail about many
aspects of the Checker Framework and its implementation.
%
% Examples?
The technical paper also describes a few features that are part of the
distribution but are not yet documented in this manual.
%
Finally, the technical
paper describes case
studies in which each of the checkers found
previously-unknown errors in real software.


\subsection{Comparison to other tools\label{other-tools}}

A pluggable type-checker, such as those created by the Checker Framework,
aims to help you prevent or detect all errors of a given variety.  An
alternate approach is to use a bug detector such as
\ahref{http://findbugs.sourceforge.net/}{FindBugs},
\ahref{http://artho.com/jlint/}{JLint}, or
\ahref{http://pmd.sourceforge.net/}{PMD}.

A pluggable type-checker
differs from a bug detector in several ways:
\begin{itemize}
\item
  A type-checker aims to find \emph{all} errors.  Thus, it can verify the
  \emph{absence} of errors:  if the type checker says there are no null
  pointer errors in your code, then there are none.  (This guarantee only
  holds for the code it checks, of course; see
  Section~\ref{checker-guarantees}.)

  A bug detector aims to find \emph{some} of the most obvious errors.  Even
  if it reports no errors, then there may still be errors in your code.

  Both types of tools may issue false positive warnings; see
  Section~\ref{suppressing-warnings}.

\item
  A type-checker requires you to annotate your code with type qualifiers,
  or to run an inference tool that does so for you.  A bug detector may not
  require annotations.  This means that it may be easier to get started
  running a bug detector.

\item
  A type-checker may use more a more sophisticated and complete analysis.
  A bug detector typically does a more lightweight analysis, coupled with
  heuristics to suppress false positives.

  As one example, a type-checker can take advantage of annotations on
  generic type parameters, such as \code{List<@NonNull String>}, permitting
  it to be much more precise for code that uses generics.

\end{itemize}

A case study~\cite[\S6]{PapiACPE2008} compared the Checker Framework's nullness
checker with those of FindBugs, JLint, and PMD\@.  The case study was on a
well-tested program in daily use.  The Checker Framework tool found 8
nullness errors.  None of the other tools found any errors.



\subsection{Credits and changelog\label{credits}}

The Checker Framework distribution was developed in the MIT Program Analysis
Group, with prime contributions from Mahmood Ali, Telmo Correa, Michael
D. Ernst, and Matthew M. Papi.
Many users have provided valuable feedback, for which we are grateful.

%% Not so accurate, since Mahmood is really an author of the nullness and
%% interned checkers too.
% The Checker Framework was implemented by 
% The nullness checker was implemented by Matthew M. Papi.
% The interning checker was implemented by Matthew M. Papi.
% The Javari checker was implemented by Telmo Correa.
% The IGJ checker was implemented by Mahmood Ali.
% The basic checker was implemented by Matthew M. Papi.

Differences from previous versions of the checkers and framework can be found
in the \code{changelog-checkers.txt} file.  This file is included in the
Checker Framework distribution and is also available on the web at
\myurl{http://types.cs.washington.edu/checker-framework/current/changelog-checkers.txt}.






% LocalWords:  jsr unsetting plugins langtools zipfile cp plugin Nullness txt
% LocalWords:  nullness classpath NonNull MyObject javac uref changelog MyEnum
% LocalWords:  subtyping containsKey proc classfiles SourceChecker javap jdk
% LocalWords:  MyFile buildfiles
