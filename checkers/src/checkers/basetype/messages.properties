### Error messages for BaseTypeChecker
assignability.invalid=Cannot (re-)assign %s through the reference: %s
receiver.invalid=incompatible types.\nfound   : %s\nrequired: %s
type.incompatible=incompatible types.\nfound   : %s\nrequired: %s
type.argument.type.incompatible=incompatible type arguments;\nfound   : %s\nrequired: %s
vector.copyinto.type.incompatible=incompatible component type of Vector.copyInto argument.\nfound   : %s\nrequired: %s
type.invalid=%s may not be applied to the type "%s"
cast.unsafe="%s" may not be casted to the type "%s"
override.return.invalid=%s in %s cannot override %s in %s; attempting to use an incompatible return type\nfound   : %s\nrequired: %s
override.param.invalid=%s in %s cannot override %s in %s; attempting to use an incompatible parameter type\nfound   : %s\nrequired: %s
override.receiver.invalid=%s in %s cannot override %s in %s; attempting to use an incompatible receiver type\nfound   : %s\nrequired: %s
method.invocation.invalid=call to %s not allowed on the given receiver.\nfound   : %s\nrequired: %s
constructor.invocation.invalid=creation of %s not allowed with given receiver;\nfound   : %s\nrequired: %s
unallowed.access=access of the field (%s) is not permitted on receiver of type (%s)
cast.redundant=Redundant unneeded cast;\ntype   : %s
pure.void.method=a pure method without return value is redundant
pure.not.sideeffect.free=method might not be side-effect free (pure), for the following reason: %s
pure.not.deterministic=method might not be deterministic (pure), for the following reason: %s
pure.not.deterministic.and.sideeffect.free=method might neither be deterministic nor side-effect free (pure), for the following reason: %s
pure.annotation.with.emtpy.kind=a pure annotation with an empty 'value' attribute is redundant
pure.determinstic.constructor=constructors cannot be deterministic
pure.more.pure=the method %s could be declared as pure: @Pure(%s)
flowexpr.parse.index.too.big=the method does not have a parameter %s
flowexpr.parse.error=cannot parse the expression '%s'
flowexpr.parameter.not.final=the parameter %s is not final, but used in '%s'
contracts.postcondition.not.satisfied=the postcondition of this method is not satisfied
contracts.conditional.postcondition.not.satisfied=the conditional postcondition at this return statement is not satisfied
contracts.conditional.postcondition.invalid.returntype=this annotation is only valid for methods with return type 'boolean'
contracts.precondition.not.satisfied=the precondition of called method is not satisfied