### Error messages for BaseTypeChecker
assignability.invalid=Cannot (re-)assign %s through the reference: %s
receiver.invalid=incompatible types.\nfound   : %s\nrequired: %s

array.initializer.type.incompatible=incompatible types in array initializer.\nfound   : %s\nrequired: %s
assignment.type.incompatible=incompatible types in assignment.\nfound   : %s\nrequired: %s
compound.assignment.type.incompatible=incompatible types in compound assignment.\nfound   : %s\nrequired: %s
enhancedfor.type.incompatible=incompatible types in enhanced for loop.\nfound   : %s\nrequired: %s
vector.copyinto.type.incompatible=incompatible component type in Vector.copyinto.\nfound   : %s\nrequired: %s
return.type.incompatible=incompatible types in return.\nfound   : %s\nrequired: %s
annotation.type.incompatible=incompatible types in annotation.\nfound   : %s\nrequired: %s
conditional.type.incompatible=incompatible types in conditional expression.\nfound   : %s\nrequired: %s
type.argument.type.incompatible=incompatible types in type argument.\nfound   : %s\nrequired: %s
argument.type.incompatible=incompatible types in argument.\nfound   : %s\nrequired: %s
type.incompatible=incompatible types.\nfound   : %s\nrequired: %s
monotonic.type.incompatible=cannot assign %s to %s (monotonic type).\nfull type found: %s
type.invalid=%s may not be applied to the type "%s"
cast.unsafe="%s" may not be casted to the type "%s"

override.return.invalid=%s in %s cannot override %s in %s; attempting to use an incompatible return type\nfound   : %s\nrequired: %s
override.param.invalid=%s in %s cannot override %s in %s; attempting to use an incompatible parameter type\nfound   : %s\nrequired: %s
override.receiver.invalid=%s in %s cannot override %s in %s; attempting to use an incompatible receiver type\nfound   : %s\nrequired: %s

method.invocation.invalid=call to %s not allowed on the given receiver.\nfound   : %s\nrequired: %s
constructor.invocation.invalid=creation of %s not allowed with given receiver;\nfound   : %s\nrequired: %s

unallowed.access=access of the field (%s) is not permitted on receiver of type (%s)
cast.redundant=Redundant cast;\ntype   : %s

purity.deterministic.void.method=a deterministic method without return value is redundant
purity.deterministic.constructor=a deterministic constructor is redundant
purity.invalid.overriding=method must be declared as @Pure because it overrides a @Pure method
purity.invalid.overriding.sideeffectfree=method must be declared as @SideEffectFree because it overrides a @SideEffectFree method
purity.invalid.overriding.deterministic=method must be declared as @Deterministic because it overrides a @Deterministic method
purity.not.deterministic.catch=catch block not allowed in deterministic method
purity.not.deterministic.call=call to non-deterministic method not allowed in deterministic method
purity.not.sideeffectfree.call=call to non-side-effect-free method not allowed in side-effect-free method
purity.not.deterministic.not.sideeffectfree.call=call to a non-deterministic non-side-effect-free method not allowed in deterministic side-effect-free method
purity.not.sideeffectfree.object.creation=object creation using a non-side-effect-free constructor not allowed in side-effect-free method
purity.not.deterministic.object.creation=object creation not allowed in deterministic method
purity.not.deterministic.not.sideeffectfree.object.creation=object creation not allowed in deterministic side-effect-free method
purity.not.deterministic.not.sideeffectfree.assign.field=field assignment not allowed in deterministic side-effect-free method
purity.not.deterministic.not.sideeffectfree.assign.array=array assignment not allowed in deterministic side-effect-free method
purity.more.pure=the method %s could be declared as @Pure
purity.more.sideeffectfree=the method %s could be declared as @SideEffectFree
purity.more.deterministic=the method %s could be declared as @Deterministic
purity.invalid.overriding=%s in %s cannot override %s in %s; attempting to use an incompatible purity declaration\nfound   : %s\nrequired: %s


flowexpr.parse.index.too.big=the method does not have a parameter %s
flowexpr.parse.error=cannot parse the expression '%s'
flowexpr.parameter.not.final=non-final parameter %s is used in '%s'
flowexpr.method.not.deterministic=only deterministic methods can be used in flow expressions; the method '%s' is not deterministic
contracts.postcondition.not.satisfied=the postcondition about '%s' of this method is not satisfied
contracts.conditional.postcondition.not.satisfied=the conditional postcondition about '%s' at this return statement is not satisfied
contracts.conditional.postcondition.invalid.returntype=this annotation is only valid for methods with return type 'boolean'
contracts.precondition.not.satisfied=the precondition about '%s' of called method is not satisfied
contracts.precondition.override.invalid=the precondition for '%s' in method %s must be weaker (or equally strong) in all subtypes
contracts.postcondition.override.invalid=the postcondition for '%s' in method %s must be stronger (or equally strong) in all subtypes
contracts.conditional.postcondition.true.override.invalid=the conditional postcondition with result=true for '%s' in method %s must be stronger (or equally strong) in all subtypes
contracts.conditional.postcondition.false.override.invalid=the conditional postcondition with result=false for '%s' in method %s must be stronger (or equally strong) in all subtypes
